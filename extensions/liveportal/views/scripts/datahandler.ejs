<!--
      StreamRoller_source Copyright 2023 "SilenusTA https://www.twitch.tv/olddepressedgamer"
 
      StreamRoller is an all in one streaming solution designed to give a single
      'second monitor' control page and allow easy integration for configuring
      content (ie. tweets linked to chat, overlays triggered by messages, hue lights
      controlled by donations etc)
 
      This program is free software: you can redistribute it and/or modify
      it under the terms of the GNU Affero General Public License as published
      by the Free Software Foundation, either version 3 of the License, or
      (at your option) any later version.
 
      This program is distributed in the hope that it will be useful,
      but WITHOUT ANY WARRANTY; without even the implied warranty of
      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      GNU Affero General Public License for more details.
 
      You should have received a copy of the GNU Affero General Public License
      along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
-->
<script src="/streamroller-message-api.cjs" onerror="scriptLoadFailed('streamroller-message-api.cjs')"></script>
<!-- placeholder we will use for inserting widgets-->
<%- include('../modals/liveportalsettingswidgetssmallplaceholder'); %>


<script>
    window.name = '_StreamRoller'
    //"use strict"
    const default_serverConfig = {
        // version number only needs updating if changing or deleting a variable.
        // new variables do not need the version updated.        
        __version__: "0.4",
        // extensions vars
        extensionname: "liveportal",
        channel: "LIVE_PORTAL",
        logginglevel: "0",

        // extensions visibility on main page
        streamersonglistdisplay: "on",
        discordmodchatdisplay: "on",
        obsdisplay: "on",
        philipshuedisplay: "on",
        macrobuttonsdisplay: "on",
        slalertsdisplay: "on",
        // obs settings
        obsdefaultstartscenename: "##Starting Soon",
        obsdefaultlivescenename: "##Game",
        obsdefaultintermissionscenename: "##Intermission",
        obsdefaultendscenename: "##StreamEnd",
        showprimaryscenes: "off",
        showsecondaryscenes: "off",
        showallscenes: "on",
        mutescene: "MIC-B1",
        muted: false,
        ClickHighlightTimer: null,
        // chat window settings
        modchattomodwindow: "on",
        // discord settings
        modmessage_channel: "stream-mod-messages", // discord channel
        donations_channel: "announcements", // discord channel
        // alerts posting to discord
        follows: "off",
        raids: "off",
        hosts: "off",
        subs: "off",
        resubs: "off",
        giftsubs: "off",
        cloudbotredemption: "off",
        merch: "off",
        bits: "off",
        donations: "off",
        chatAsUsername: "user",

        // ##### settings widget variables
        // TTS settings
        winttstwitchenabled: "off",
        twitchTTSVolume: "1",
        twitchBlackList: "",
        twitchTTSVoiceName: "Please select a windows voice",
        twitchTTSVoiceIndex: -1,
        winttsyoutubeenabled: "off",
        youtubeTTSVolume: "1",
        youtubeBlackList: "",
        YouTubeTTSVoiceName: "Please select a windows voice",
        YouTubeTTSVoiceIndex: -1,
        TTSVoiceFilter: "", // filter out voices you are interested in

        // random facts twitter settings
        randomfactsenabled: "on",
        randomfactstimeout: 1800000,//30 min

        randomfactstwitterstartenabled: "on",
        twitterstartenabled: "off",
        twitterstartmessage: "We're live twitch.tv/OldDepressedGamer",
        twitterstartmessage_x: "Come say Hi!",
        // max display size to maintain
        chatmessagebuffermaxsize: 300,
        discordmessagebuffermaxsize: 300,
        liveportal_restore_defaults: "off",
        liveportal_monitor_heap: "off"

    };
    let serverConfig = structuredClone(default_serverConfig);
    const default_serverData = {
        __version__: "0.1.2",
    }

    let serverData = structuredClone(default_serverData);

    const localConfig =
    {
        OBSSceneslist: {},
        obslive: false, // set on a heartbeat from obs messages
        deadmansHeartBeatTimeout: "6000", // sets extensions to off if heartbeat stops
        deadmansHeartBeatHandle: null,
        twitchchatchannel: "",
        twitchplatformavailable: false,
        youtubeplatformavailable: false,
        youtubechatchannel: "",
        chatMessageBuffer: [],
        modMessageBuffer: [],
        mouseDown: 0,
        randomFact: "",
        twitchRandomFactHandle: null,
        timers: [],
        newTwitchChatBuffer: false,
        newDiscordChatBuffer: false,
        // streamersonglist variables
        setreamersonglist: { songlist: [], queue: { status: { "songsPlayedToday": "0" }, list: [] } },
        //philips hugh variables
        philipsHueSceneList: [],
        triggersAndActions: { extensiondescriptions: [], triggers: [], actions: [] },
        host: "localhost",
        port: "3000",
        displaySettings: {
            triggerPage: {
                selectedGroup: ""
            }
        },
        softwareVersion: "",
        latestRelease:
        {
            name: "",
            exe: "",
            zip: ""
        },
        bTTVEmotes: null,
        bTTVNames: [],
        TTSVoiceList: [],
        bannedUsersList: [],

        LargeSettingsDataCacheHandle: null,
        LargeSettingsDataCacheTimeout: 500,
        addALLSettingsWidgetLargeRunning: false,

        documentHiddenConnectHandler: null,
        documentHiddenConnectTimeout: 1000,
    }
    const chatcolors =
    {
        //general use colors
        default_darkred_color: "darkred",
        default_greyout_color: "#adadad",
        default_system_color: "red",
        default_username_color: "#7097ff",//#6f42c1",
        default_timecode_color: "#757875",
        default_user_at_color: "red",
        default_text_bright_color: "white",
        default_sub_color: "#03b503",
        default_reward_color: "red",
        default_reward_bgcolor: "#fdff00",
        default_mod_action: "yellow",
        // yet to be processed colors
        default_TBD_background_color: "purple",
        default_TBD_text_color: "yellow",
    }

    // will hold the data center socket needed to send receive data
    // after refactoring the code this should hopefully not be needed anymore
    let DataCenterSocket = null;

    // truncates long log messages for easier reading. 
    const LOGGING_MAX_MESSAGE_LENGTH = 200

    //global volatile data store for the app
    const livePortalVolatileData = {};
    livePortalVolatileData.extensions = {};
    livePortalVolatileData.channellist = {};
    localConfig.host = '<%= host %>';
    localConfig.port = '<%= port %>';
    // need our callback timeout to be longer than the system times as this is a
    // deadmans heartbeat monitor
    localConfig.deadmansHeartBeatTimeout = parseInt('<%= heartbeat %>') + 1000;
    // check for mousedown as we might need to stop the chat scroll when the user is trying to scroll the box
    document.body.onmousedown = function () { localConfig.mouseDown = true }
    document.body.onmouseup = function () { localConfig.mouseDown = false }
    /* This block is to avoid the extensions being loaded before we have loaded our own settings. Websocket is quicker than our webpage */
    window.addEventListener('load',
        function ()
        {
            LoadPages
                .then((result) =>
                {
                    ConnectToDataCenter(localConfig.host, localConfig.port);
                    deadMansHeartBeatCallback();
                    LoadVoices()
                })
                .catch((error) =>
                {
                    ConnectToDataCenter(localConfig.host, localConfig.port);
                    deadMansHeartBeatCallback();
                    console.log('LoadPages error:', error.message);
                });

        });
    // ============================================================================
    //                           FUNCTION: Load our settings pages
    // ============================================================================
    const LoadPages = new Promise((resolve, reject) =>
    {
        try
        {
            // lets load our placeholder modal code. This is so we can update our own code the same way as the extensions
            livePortalVolatileData.extensions[serverConfig.extensionname] = { settingswidgetsmall_placeholder: "", settingswidgetlarge_placeholder: "" }
            fetch("liveportal/modals/liveportalsettingswidgetsmall_placeholder.html")
                .then(response => response.text())
                .then(data => 
                {
                    livePortalVolatileData.extensions[serverConfig.extensionname].settingswidgetsmall_placeholder = data;
                    fetch("liveportal/modals/liveportalsettingswidgetlarge_placeholder.html")
                        .then(response => response.text())
                        .then(data => 
                        {
                            livePortalVolatileData.extensions[serverConfig.extensionname].settingswidgetlarge_placeholder = data
                            resolve("Success");
                            checkForNewSoftwareVersion();
                        })
                })
                .catch(error => console.log("LoadPages failed with error :", error))
        }
        catch (error)
        {
            reject(error)
        }

    });
    // ============================================================================
    //                           FUNCTION: Load BTTV Emotes
    // ============================================================================
    const LoadBTTVEmotes = new Promise((resolve, reject) =>
    {
        try
        {
            fetch("https://api.betterttv.net/3/cached/emotes/global")
                .then(response => response.text())
                .then(data => 
                {
                    let dataJson = JSON.parse(data)
                    localConfig.bTTVEmotes = dataJson
                    for (var key of Object.keys(dataJson))
                    {
                        localConfig.bTTVNames.push(dataJson[key].code)
                    }
                })
                .catch(error => console.log("LoadBTTVEmotes failed with error :", error))
        }
        catch (error)
        {
            reject(error)
        }

    });
    // ============================================================================
    //                           FUNCTION: scriptLoadFailed
    // ============================================================================
    // Description: Runs when a script fails to load (404 error)
    function scriptLoadFailed (scriptname)
    {
        console.log("failed to load", scriptname, "reloading page")
        setTimeout(() =>
        {
            location.reload();
        }, 5000);
    }
    // ============================================================================
    //                           FUNCTION: ConnectToDataCenter
    // ============================================================================
    // Description: Connect to the data center socket
    // Parameters: none
    // ----------------------------- notes ----------------------------------------
    // none
    // ===========================================================================
    function ConnectToDataCenter (host, port)
    {
        localConfig.host = host;
        localConfig.port = port;
        try
        {
            DataCenterSocket = sr_api.setupConnection(onDataCenterMessage, onDataCenterConnect, onDataCenterDisconnect,
                host, port);
        } catch (err)
        {
            console.log("datahandler.initialise", "DataCenterSocket connection failed:", err);
        }
    }
    // ============================================================================
    //                           FUNCTION: onDataCenterDisconnect
    // ============================================================================
    // Description: Received disconnect message
    // Parameters: none
    // ----------------------------- notes ----------------------------------------
    // none
    // ===========================================================================
    function onDataCenterDisconnect (reason)
    {
        // remove all the other extensions but ours (lost datacenter means we only have ourselves to play with now)
        for (const key in livePortalVolatileData.extensions)
        {
            // hide any open models as they break the focus if not hidden
            $('#' + key + "_settingswidgetsmallmodal").modal("hide")
            if (key != serverConfig.extensionname)
                delete livePortalVolatileData.extensions[key];
        }
        livePortalVolatileData.channellist = {};
        // clear out and reload the extensions list to make it obvious we have lost connetion
        loadExtensionCards([])
        document.getElementById("ExtensionsListCard").getElementsByClassName("card-text")[0].innerHTML = "<div style='color:red'>Server Disconnected<BR>Waiting for connection ...</div>";

    }
    // ============================================================================
    //                           FUNCTION: onDataCenterConnect
    // ============================================================================
    // Description: Received connect message
    // Parameters: none
    // ----------------------------- notes ----------------------------------------
    // none
    // ===========================================================================
    function onDataCenterConnect (socket)
    {
        // Request the stuff we need first here
        // We give the system some time to get things in and delay some of the longer stuff till the end (like the chat buffers) 
        // This is just to allow the extensions to get up and running
        startupRequests();
    }
    // ============================================================================
    //                           FUNCTION: startupRequests
    // This function will suppress multiple startup startup requests when the page 
    // is hidden
    // ============================================================================
    function startupRequests ()
    {
        // check if we already have a handle
        if (localConfig.documentHiddenConnectHandler != null)
        {
            clearTimeout(localConfig.documentHiddenConnectHandler)
            localConfig.documentHiddenConnectHandler = null;
        }
        // if the page is hidden lets not request all the startup stuff as the socket connection
        // will repeatedly timeout and reconnect when in the background.
        if (document.hidden)
        {
            localConfig.documentHiddenConnectHandler = setTimeout(() =>
            {
                startupRequests()
            }, localConfig.documentHiddenConnectTimeout)
            return;
        }
        localConfig.documentHiddenConnectHandler = setTimeout(() =>
        {
            sr_api.sendMessage(DataCenterSocket,
                sr_api.ServerPacket(
                    "RequestConfig",
                    serverConfig.extensionname
                ));

            //request software version
            sr_api.sendMessage(DataCenterSocket,
                sr_api.ServerPacket(
                    "RequestSoftwareVersion",
                    serverConfig.extensionname,
                    serverConfig.channel
                ));

            sr_api.sendMessage(DataCenterSocket,
                sr_api.ServerPacket("RequestData", serverConfig.extensionname));

            sr_api.sendMessage(DataCenterSocket,
                sr_api.ServerPacket("CreateChannel", serverConfig.extensionname, serverConfig.channel)
            );
            RequestExtList();
            RequestLoggingLevel();
            setTimeout(() =>
            {
                RequestRandomFact();
                RequestTwitchAccountNames("twitchchat");
                setTimeout(() =>
                {
                    RequestChatBuffer("twitchchat");
                    setTimeout(() =>
                    {
                        RequestSongLists();
                        RquestPhilipsHueData();
                        RequestChatBuffer("discordchat");
                        RequestMacros();
                        RequestTwitchStats()
                        if (serverConfig.randomfactsenabled === "on" && serverConfig.randomfactstimeout > 0)
                            twitchFactOfTheDay();
                    }, 1000);
                }, 500);
            }, 500);
        }, 1000);
    }
    // ============================================================================
    //                           FUNCTION: onDataCenterMessage
    // ============================================================================
    // Description: Received message
    // Parameters: none
    // ----------------------------- notes ----------------------------------------
    // none
    // ===========================================================================
    function onDataCenterMessage (server_packet)
    {
        // -------------------------------------------------------------------------------------------------
        //                  RECEIVED CONFIG
        // -------------------------------------------------------------------------------------------------
        if (server_packet.type === "ConfigFile")
        {

            // check it is our config
            if (server_packet.data && server_packet.data.extensionname
                && server_packet.data.extensionname === serverConfig.extensionname)
            {
                let configSubVersions = 0;
                let defaultSubVersions = default_serverConfig.__version__.split('.');
                if (server_packet.data == "")
                {
                    // server data is empty, possibly the first run of the code so just default it
                    serverConfig = structuredClone(default_serverConfig);
                    SaveConfigToServer();
                }
                else
                    configSubVersions = server_packet.data.__version__.split('.')

                if (configSubVersions[0] != defaultSubVersions[0])
                {
                    // Major version number change. Replace config with defaults
                    // perform a deep clone overwriting our server config.
                    serverConfig = structuredClone(default_serverConfig);
                    // notify the user their config has been updated.
                    console.log("\x1b[31m" + serverConfig.extensionname + " ConfigFile Updated", "The config file has been Updated to the latest version v" + default_serverConfig.__version__ + ". Your settings may have changed" + "\x1b[0m");
                    SaveConfigToServer();
                }
                else if (configSubVersions[1] != defaultSubVersions[1])
                {
                    // Minor version number change. Overwrite config with defaults
                    // perform a merge replacing any values we currently have and keeping the new variables
                    serverConfig = { ...default_serverConfig, ...server_packet.data };
                    // update the version number to the current default number
                    serverConfig.__version__ = default_serverConfig.__version__;
                    console.log(serverConfig.extensionname + " ConfigFile Updated", "The config file has been Updated to the latest version v" + default_serverConfig.__version__);
                    SaveConfigToServer();
                }
                else
                {
                    // no version number changed so we can just use the saved file
                    serverConfig = structuredClone(server_packet.data);
                }
                setCardsVisibility();
                // update our modal to match the new data
                UpdateOwnSettingsWidgetSmallData();
                UpdateOwnSettingsWidgetLargeData();

                ParseOBSScenesList(localConfig.OBSSceneslist);
                updatePhilipsHueDisplay();
            }
        }
        else if (server_packet.type === "DataFile")
        {
            if (server_packet.data == "")
            {
                // server data is empty, possibly the first run of the code so just default it
                serverConfig = structuredClone(default_serverConfig);
                SaveConfigToServer();
            }
            else if (server_packet.to === serverConfig.extensionname)
            {
                if (server_packet.data.__version__ != default_serverData.__version__)
                {
                    serverData = structuredClone(default_serverData);
                    console.log("\x1b[31m" + serverConfig.extensionname + " Datafile Updated", "The Data file has been Updated to the latest version v" + default_serverData.__version__ + ". Your settings may have changed" + "\x1b[0m");
                }
                else
                {
                    if (server_packet.data != "")
                    {
                        serverData = structuredClone(server_packet.data);
                    }
                }
                SaveDataToServer();
            }
        }
        // -------------------------------------------------------------------------------------------------
        //                  RECEIVED CHANNEL LIST
        // -------------------------------------------------------------------------------------------------
        else if (server_packet.type === "ChannelList")
        {
            livePortalVolatileData.channellist = server_packet.data;
            //need to add our own channel as the server doesn't bounce messages back to us when we join
            livePortalVolatileData.channellist.push(serverConfig.channel)
            livePortalVolatileData.channellist.forEach(element =>
            {
                if (element != serverConfig.channel)
                    sr_api.sendMessage(DataCenterSocket,
                        sr_api.ServerPacket(
                            "JoinChannel",
                            serverConfig.extensionname,
                            element
                        ));
            });
        }
        // -------------------------------------------------------------------------------------------------
        //                  RECEIVED LOGGING LEVEL
        // -------------------------------------------------------------------------------------------------
        else if (server_packet.type === "LoggingLevel")
        {
            if (serverConfig.logginglevel != server_packet.data)
            {
                serverConfig.logginglevel = server_packet.data
                UpdateOwnSettingsWidgetSmallData();
                UpdateOwnSettingsWidgetLargeData();
                //send modal to everyone to update their own copies of out model
                SendSettingsWidgetSmall("");
                SendSettingsWidgetLarge("");
            }
        }
        // -------------------------------------------------------------------------------------------------
        //                  RECEIVED LOGGING LEVEL
        // -------------------------------------------------------------------------------------------------
        else if (server_packet.type === "SoftwareVersion")
        {
            localConfig.softwareVersion = server_packet.data
            document.getElementById("softwareversion").innerHTML = server_packet.data;
            checkForNewSoftwareVersion()

        }
        // -------------------------------------------------------------------------------------------------
        //                   RECEIVED EXTENSION LIST
        // -------------------------------------------------------------------------------------------------
        else if (server_packet.type === "ExtensionList")
        {
            //load extension cards
            loadExtensionCards(server_packet.data);
            if (server_packet.data.includes("obs"))
            {
                RequestOBSScenes("obs");
            }
        }
        else if (server_packet.type === "ExtensionMessage")
        {
            let extension_packet = server_packet.data;
            // -------------------------------------------------------------------------------------------------
            //                   RECEIVED SETTINGS WIDGET SMALL REQUEST
            // -------------------------------------------------------------------------------------------------
            if (extension_packet.type == "SongQueue")
            {
                updateSingerSonglistQueue(extension_packet.data)
            }
            // -------------------------------------------------------------------------------------------------
            //                   RECEIVED SETTINGS WIDGET SMALL REQUEST
            // -------------------------------------------------------------------------------------------------
            else if (extension_packet.type == "SongList")
            {
                if (extension_packet.data && extension_packet.data.items)
                    updateSingerSonglistList(extension_packet.data.items)
            }
            // -------------------------------------------------------------------------------------------------
            //                   RECEIVED SETTINGS WIDGET SMALL REQUEST
            // -------------------------------------------------------------------------------------------------
            else if (extension_packet.type === "RequestSettingsWidgetSmallCode")
            {
                if (extension_packet.from == "undefined")
                {
                    console.log("RequestSettingsWidgetSmallCode undefined from")
                    console.log(extension_packet)
                }
                SendSettingsWidgetSmall(extension_packet.from);
            }

            // -------------------------------------------------------------------------------------------------
            //                   RECEIVED SETTINGS WIDGET LARGE REQUEST
            // -------------------------------------------------------------------------------------------------
            else if (extension_packet.type === "RequestSettingsWidgetLargeCode")
            {
                SendSettingsWidgetLarge(extension_packet.from);
            }
            // -------------------------------------------------------------------------------------------------
            //                   RECEIVED EXTENSION MODAL CODE
            // -------------------------------------------------------------------------------------------------
            else if (extension_packet.type === "SettingsWidgetSmallCode")
            {
                // we process our own submits so don't do anything with the updates we send out if they come 
                // back to us
                if (extension_packet.from != serverConfig.extensionname && livePortalVolatileData.extensions[extension_packet.from])
                {
                    livePortalVolatileData.extensions[extension_packet.from].settingswidgetsmall = extension_packet.data
                    addSettingsWidgetSmall(extension_packet.from);
                }
            }
            // -------------------------------------------------------------------------------------------------
            //                   RECEIVED EXTENSION MODAL CODE
            // -------------------------------------------------------------------------------------------------
            else if (extension_packet.type === "SettingsWidgetLargeCode")
            {
                // we process our own submits so don't do anything with the updates we send out if they come 
                // back to us
                if (extension_packet.from != serverConfig.extensionname)
                {
                    livePortalVolatileData.extensions[extension_packet.from].settingswidgetlarge = extension_packet.data
                    addALLSettingsWidgetLargeScheduler();
                }
            }
            // -------------------------------------------------------------------------------------------------
            //                   RECEIVED MODAL DATA (someone hit submit on our dialog)
            // -------------------------------------------------------------------------------------------------
            else if (extension_packet.type === "SettingsWidgetSmallData")
            {
                // check that it is not from us as we process our own code internally
                if (extension_packet.from != serverConfig.extensionname)
                {
                    // lets reset our config checkbox settings (modal will omit ones not
                    // checked in checkboxes so set them to "off" here first if you have them)
                    // set our config values to the ones in message
                    //for (const [key, value] of Object.entries(extension_packet.data))
                    //        serverConfig[key] = value;
                    for (const [key, value] of Object.entries(serverConfig))
                    {
                        //lets check our settings and send out updates as required
                        if (value === "on" && !extension_packet.data[key])
                            serverConfig[key] = "off";
                        else if (key === "randomfactstimeout")
                            serverConfig[key] = extension_packet.data[key] * 60000
                        else if (key in extension_packet.data)
                            serverConfig[key] = extension_packet.data[key];
                    }

                    changeServerLogging(serverConfig.logginglevel)
                    // save our data to the server for next time we run
                    SaveConfigToServer();
                    //lets update our modals
                    UpdateOwnSettingsWidgetSmallData();
                    UpdateOwnSettingsWidgetLargeData();
                    // update anyone that may have out modal
                    SendSettingsWidgetSmall("");
                    SendSettingsWidgetLarge("");

                    ParseOBSScenesList(localConfig.OBSSceneslist);
                    // setup timeout for facts on stream
                    if (serverConfig.randomFactsEnabled === "on" && serverConfig.randomFactsTimeout > 0)
                        twitchFactOfTheDay();

                }
            }
            // -------------------------------------------------------------------------------------------------
            //                   RECEIVED MODAL DATA (someone hit submit on our dialog (should be sent directly to us))
            // -------------------------------------------------------------------------------------------------
            else if (extension_packet.type === "SettingsWidgetLargeData")
            {
                // check that it is not from us as we process our own code internally
                if (extension_packet.from != serverConfig.extensionname)
                {
                    if (extension_packet.data.liveportal_restore_defaults == "on")
                    {
                        serverConfig = structuredClone(default_serverConfig);
                        serverData = structuredClone(default_serverData);
                        return;
                    }
                    else
                    {
                        for (const [key, value] of Object.entries(serverConfig))
                        {
                            //lets check our settings and send out updates as required
                            if (value === "on" && !extension_packet.data[key + "_SettingsSmallFormItem"])
                                serverConfig[key] = "off";
                            else if (key === "randomfactstimeout" + "_SettingsSmallFormItem")
                                serverConfig[key] = extension_packet.data[key + "_SettingsSmallFormItem"] * 60000
                            else if (key + "_SettingsSmallFormItem" in extension_packet.data)
                                serverConfig[key] = extension_packet.data[key + "_SettingsSmallFormItem"];
                        }
                    }

                    changeServerLogging(serverConfig.logginglevel)
                    // save our data to the server for next time we run
                    SaveConfigToServer();
                    //lets update our modals
                    UpdateOwnSettingsWidgetSmallData();
                    UpdateOwnSettingsWidgetLargeData();
                    // update anyone that may have out modal
                    SendSettingsWidgetSmall("");
                    SendSettingsWidgetLarge("");

                    ParseOBSScenesList(localConfig.OBSSceneslist);
                    // setup timeout for facts on stream
                    if (serverConfig.randomFactsEnabled === "on" && serverConfig.randomFactsTimeout > 0)
                        twitchFactOfTheDay();

                }
            }
            // -------------------------------------------------------------------------------------------------
            //                   RECEIVED Scenes list from OBS
            // -------------------------------------------------------------------------------------------------
            else if (extension_packet.type === "ScenesList")
            {
                ParseOBSScenesList(extension_packet.data)
            }
            // -------------------------------------------------------------------------------------------------
            //                   RECEIVED Twitch chat buffer
            // -------------------------------------------------------------------------------------------------
            else if (extension_packet.type === "TwitchChatBuffer")
            {
                localConfig.newTwitchChatBuffer = true
                // recreate our buffer
                processTwitchChatBuffer(extension_packet.data)
                    .then(() =>
                        // display the chat buffer
                        displayChatMessages()

                    )
            }
            // -------------------------------------------------------------------------------------------------
            //                   RECEIVED Twitch chat buffer
            // -------------------------------------------------------------------------------------------------
            else if (extension_packet.type === "UserAccountNames")
            {
                processTwitchAccountNames(extension_packet)
            }
            // -------------------------------------------------------------------------------------------------
            //                   RECEIVED Discord chat buffer
            // -------------------------------------------------------------------------------------------------
            else if (extension_packet.type === "DiscordChatBuffer")
            {
                localConfig.newDiscordChatBuffer = true
                // recreate our buffer
                processDiscordChatBuffer(extension_packet.data)
                    .then(() =>
                        // display the chat buffer
                        displayChatMessages()

                    )
            }
            // -------------------------------------------------------------------------------------------------
            //                   RECEIVED chatbot message directly to us
            // -------------------------------------------------------------------------------------------------
            else if (extension_packet.type === "trigger_chatbotResponse")
            {
                // these are responses from chatbot that got sent directly (ie not as chatbot chat functionality)
                sr_api.sendMessage(DataCenterSocket,
                    sr_api.ServerPacket("ExtensionMessage",
                        serverConfig.extensionname,
                        sr_api.ExtensionPacket(
                            "action_SendChatMessage",
                            serverConfig.extensionname,
                            // need to read accounts from twitchchat ext and give an option to chose who to send the message as
                            {
                                account: "bot",
                                message: extension_packet.data.response,
                                'message-type': "AIchatbotmessage"
                            },
                            "",
                            "twitchchat"),
                        "",
                        "twitchchat"
                    ));
            }
            // -------------------------------------------------------------------------------------------------
            //                   RECEIVED AutopilotServerData
            // -------------------------------------------------------------------------------------------------
            else if (extension_packet.type === "ServerConfigForDownload")
            {
                if (extension_packet.to == serverConfig.extensionname)
                    // This file will only be received on user request to save the data so we can 
                    // call the save function directly here
                    try
                    {   // should only be called via a users request to download the server file after
                        // we have received the file from the server
                        let fileToDownload = JSON.stringify(extension_packet.data, null, 2);
                        var a = document.createElement("a");
                        var file = new Blob([fileToDownload], { type: "application/json" });
                        a.href = URL.createObjectURL(file);
                        a.download = "StreamRoller_" + extension_packet.from + "_Backup_" + getFileNameDateString() + ".json";
                        a.click();
                    }
                    catch (err)
                    {
                        console.log("downloadServerDataFileReceived Error:", err, err.message)
                    }
            }
            // -------------------------------------------------------------------------------------------------
            //                   RECEIVED AutopilotServerDataUseSaveResponse
            // -------------------------------------------------------------------------------------------------
            else if (extension_packet.type === "UserSaveServerDataResponse")
            {
                if (extension_packet.to == serverConfig.extensionname)
                    // This file will only be received on user request to save the data so we can 
                    // call the save function directly here
                    alert(extension_packet.data.response);
            }
            // -------------------------------------------------------------------------------------------------
            //                   RECEIVED Unhandled extension message
            // -------------------------------------------------------------------------------------------------
            else
            {
                // console.log(".onDataCenterMessage", "ExtensionMessage not handled ", extension_packet.type, " from ", extension_packet.from);
            }
        }
        // -------------------------------------------------------------------------------------------------
        //                   RECEIVED CHANNEL DATA
        // -------------------------------------------------------------------------------------------------
        else if (server_packet.type === "ChannelData")
        {
            let extension_packet = server_packet.data;
            // -------------------------------------------------------------------------------------------------
            //                   RECEIVED CHANNEL MODAL CODE
            // -------------------------------------------------------------------------------------------------
            if (extension_packet.type === "SettingsWidgetSmallCode")
            {
                // we process our own submits so don't do anything with the updates we send out if they come 
                // back to us
                if (extension_packet.from != serverConfig.extensionname && livePortalVolatileData.extensions[extension_packet.from])
                {
                    livePortalVolatileData.extensions[extension_packet.from].settingswidgetsmall = extension_packet.data
                    addSettingsWidgetSmall(extension_packet.from);
                }
            }
            // -------------------------------------------------------------------------------------------------
            //                   RECEIVED CHANNEL MODAL CODE
            // -------------------------------------------------------------------------------------------------
            else if (extension_packet.type === "SettingsWidgetLargeCode")
            {
                // we process our own submits so don't do anything with the updates we send out if they come 
                // back to us
                if (extension_packet.from != serverConfig.extensionname)
                {
                    livePortalVolatileData.extensions[extension_packet.from].settingswidgetlarge = extension_packet.data
                    addALLSettingsWidgetLargeScheduler();
                }
            }
            // -------------------------------------------------------------------------------------------------
            //                           CheckForTrigger
            // -------------------------------------------------------------------------------------------------
            //if (extension_packet.type.startsWith("trigger_"))
            //    CheckTriggers(extension_packet)
            // -------------------------------------------------------------------------------------------------
            //                           HEARTBEAT
            // -------------------------------------------------------------------------------------------------
            else if (extension_packet.type === "HeartBeat")
            {
                //check if we have this extension
                if (typeof (livePortalVolatileData.extensions[extension_packet.from]) !== "undefined")
                {
                    //clear the previous timeout handle
                    clearTimeout(livePortalVolatileData.extensions[extension_packet.from].deadmansHeartBeatHandle);
                    // setup a new timeout for this extension
                    livePortalVolatileData.extensions[extension_packet.from].deadmansHeartBeatHandle = setTimeout(() => 
                    {
                        deadMansHeartBeatCallback(extension_packet.from)
                    },
                        localConfig.deadmansHeartBeatTimeout);

                    // set the on screen status for this extension
                    setExtensionStatus(extension_packet.from, extension_packet.data)
                    // set the available chat message options (ie youtube/twitch)
                    if (extension_packet.from == "twitchchat")
                    {
                        // check if we are able to use the platform
                        let connected = extension_packet.data.stats.botconnected || extension_packet.data.stats.userconnected
                        // check if we need to do an update or not
                        if (localConfig.twitchplatformavailable != connected)
                        {
                            localConfig.twitchplatformavailable = connected
                            updateChatPlatforms();
                        }
                    }
                    else if (extension_packet.from == "youtube" || extension_packet.from == "youtubeapi")
                    {
                        // check if we are able to use the platform
                        if (extension_packet.data.connected != localConfig.youtubeplatformavailable)
                        {
                            localConfig.youtubeplatformavailable = extension_packet.data.connected
                            updateChatPlatforms();
                        }

                    }
                }
                else
                {
                    console.log("Heartbeat Received: missing extensions for ", extension_packet.from, ", requesting again")
                    RequestExtList();
                }
            }
            // -------------------------------------------------------------------------------------------------
            //                   RECEIVED trigger and action data
            // -------------------------------------------------------------------------------------------------
            else if (extension_packet.type === "UserMacros")
            {
                localConfig.macros = structuredClone(extension_packet.data);
                updateMacroButtonsDisplay(extension_packet.data)
            }
            // -------------------------------------------------------------------------------------------------
            //                           STREAMLABS_ALERT
            // -------------------------------------------------------------------------------------------------
            else if (server_packet.dest_channel === "STREAMLABS_ALERT")
            {
                if (extension_packet.data != undefined)
                    ProcessStreamlabsAlert(extension_packet);
            }
            // -------------------------------------------------------------------------------------------------
            //                           CHATMOOD_CHANNEL
            // -------------------------------------------------------------------------------------------------
            else if (server_packet.dest_channel === "CHATMOOD_CHANNEL")
                console.log("CHATMOOD_CHANNEL received", extension_packet.data)
            // -------------------------------------------------------------------------------------------------
            //                           TWITCH_CHAT
            // -------------------------------------------------------------------------------------------------
            else if (server_packet.dest_channel == "TWITCH_CHAT")
            {
                if (extension_packet.type === "ChatMessage")
                {
                    if (serverConfig.winttstwitchenabled == "on")
                    {
                        //check for username or Displayname (timeout/ban messgges don't seem to have username field)
                        let username = ""
                        if (extension_packet.data.data.username)
                            username = extension_packet.data.data.username
                        else if (extension_packet.data["display-name"])
                            username = extension_packet.data["display-name"]
                        if (
                            serverConfig.twitchBlackList && serverConfig.twitchBlackList.toLowerCase().indexOf(username) == -1)
                            TTSSpeak(serverConfig.twitchTTSVoiceIndex, extension_packet.data.message, serverConfig.twitchTTSVolume)
                    }
                    parseTwitchChatMessage(extension_packet.data);
                    displayChatMessages();
                }
            }
            // -------------------------------------------------------------------------------------------------
            //                           YOUTUBEAPI
            // -------------------------------------------------------------------------------------------------
            else if (server_packet.dest_channel == "YOUTUBEAPI")
            {
                if (extension_packet.type === "trigger_ChatMessageReceived")
                {
                    if (serverConfig.winttsyoutubeenabled == "on")
                    {
                        if (serverConfig.youtubeBlackList.toLowerCase().indexOf(extension_packet.data.parameters.sender.toLowerCase()) == -1)
                            TTSSpeak(serverConfig.YouTubeTTSVoiceIndex, extension_packet.data.parameters.message, serverConfig.youtubeTTSVolume)
                    }
                    parseYoutubeChatMessage(extension_packet.data.parameters);
                    displayChatMessages();
                }
            }
            // -------------------------------------------------------------------------------------------------
            //                           YOUTUBE
            // -------------------------------------------------------------------------------------------------
            else if (server_packet.dest_channel == "YOUTUBE")
            {
                if (extension_packet.type === "trigger_ChatMessageReceived")
                {
                    if (serverConfig.winttsyoutubeenabled == "on")
                    {
                        if (serverConfig.youtubeBlackList.toLowerCase().indexOf(extension_packet.data.parameters.sender.toLowerCase()) == -1)
                            TTSSpeak(serverConfig.YouTubeTTSVoiceIndex, extension_packet.data.parameters.message, serverConfig.youtubeTTSVolume)
                    }
                    parseYoutubeChatMessage(extension_packet.data.parameters);
                    displayChatMessages();
                }
            }
            // -------------------------------------------------------------------------------------------------
            //                           TWITCH
            // -------------------------------------------------------------------------------------------------
            else if (server_packet.dest_channel == "TWITCH")
            {
                if (extension_packet.type === "trigger_TwitchRedemptionAdd")
                {
                    parseTwitchRedemption(extension_packet.data);
                    displayChatMessages();
                }
                else if (extension_packet.type === "trigger_TwitchGamedChanged")
                {
                    let ele = document.getElementById("liveportaltitleTwitchCategoryImage")
                    let imagecode = extension_packet.data.parameters.imageURL.replace("{width}", 30).replace("{height}", 30)
                    ele.title = extension_packet.data.parameters.name;
                    ele.innerHTML = "<img style='border: 5px solid #6441a5; border-radius:50%' src='" + imagecode + "'>"
                }
            }
            // -------------------------------------------------------------------------------------------------
            //                           DISCORD_CHAT
            // -------------------------------------------------------------------------------------------------
            else if (server_packet.dest_channel == "DISCORD_CHAT")
            {
                if (extension_packet.type === "trigger_DiscordMessageReceived")
                {
                    parseDiscordChatMessage(server_packet.data.data);
                    //displayDiscordMessages(server_packet);
                    displayChatMessages();
                }
            }
            // -------------------------------------------------------------------------------------------------
            //                           TIMERS_CHANNEL
            // -------------------------------------------------------------------------------------------------
            else if (server_packet.dest_channel == "TIMERS")
            {
                if (extension_packet.type === "trigger_TimerRunning")
                {
                    processTimers(extension_packet.data.parameters);
                    // update the obs button timer if we are running a start countdown
                    if (extension_packet.data.parameters.name == 'StartCountdownTimer')
                    {
                        UpdateOBSCountdownTimer();
                    }
                }
            }
            // -------------------------------------------------------------------------------------------------
            //                           OBS_CHANNEL
            // -------------------------------------------------------------------------------------------------
            else if (server_packet.dest_channel == "OBS_CHANNEL")
            {
                if (extension_packet.type === "ScenesList")
                    ParseOBSScenesList(extension_packet.data)
                else if (extension_packet.type === "trigger_SceneChanged")
                {
                    localConfig.OBSSceneslist.current = extension_packet.data.parameters.sceneName;
                    ParseOBSScenesList(localConfig.OBSSceneslist);
                }
                else if (extension_packet.type === "OBSStats")
                {
                    // need to check in case we missed the start message (stream already running when we load the page)
                    if (!localConfig.obslive)
                    {
                        localConfig.obslive = extension_packet.data.obslive;
                        OBSLiveCheck();
                    }

                    ProcessOBSStats(extension_packet.data);
                }
                else if (extension_packet.type === "trigger_StreamStarted")
                {
                    localConfig.obslive = true;
                    OBSLiveCheck();
                    // send tweet to say we are live
                    if (serverConfig.twitterstartenabled)
                        postMessageToTwitter(serverConfig.twitterstartmessage, serverConfig.twitterstartmessage_x);
                }
                else if (extension_packet.type === "trigger_StreamStopped")
                {
                    localConfig.obslive = false;
                    OBSLiveCheck();
                }
                else if (extension_packet.type === "MuteStatus")
                {
                    if (extension_packet.data.scene === serverConfig.mutescene)
                    {
                        serverConfig.muted = extension_packet.data.muted
                        addOBSMuteButton(serverConfig.muted)
                        OBSLiveCheck();
                    }
                }
                else
                    console.log(".onDataCenterMessage", "OBS_CHANNEL message ignored ", extension_packet.type, " from ", extension_packet.from);
            }
            else if (server_packet.dest_channel == "STREAMERSONGLIST_CHANNEL")
            {
                if (extension_packet.type == "SongQueue")
                    updateSingerSonglistQueue(extension_packet.data)
                else if (extension_packet.type == "SongList")
                    updateSingerSonglistList(extension_packet.data.items)
            }
            else if (server_packet.dest_channel == "PHILIPSHUE_CHANNEL")
            {
                // -------------------------------------------------------------------------------------------------
                //                   RECEIVED Discord chat buffer
                // -------------------------------------------------------------------------------------------------
                if (extension_packet.type === "PhilipsHueScenes")
                {
                    localConfig.philipsHueSceneList = extension_packet.data
                    processPhilipsHueScenes();
                }
            }
            // -------------------------------------------------------------------------------------------------
            //                           IGNORED CHANNELS
            //                      These are most likely ones we only use for triggers and alerts
            // -------------------------------------------------------------------------------------------------
            else if (server_packet.dest_channel == "RANDOMFACT_CHANNEL")
            {
                // -------------------------------------------------------------------------------------------------
                //                   RECEIVED Received random fact
                // -------------------------------------------------------------------------------------------------
                if (extension_packet.type === "trigger_RandomFact")
                    processRandomFact(extension_packet.data.parameters.randomFact);
            }
            // -------------------------------------------------------------------------------------------------
            //                           IGNORED CHANNELS
            //                      These are most likely ones we only use for triggers and alerts
            // -------------------------------------------------------------------------------------------------
            else if (server_packet.dest_channel == "CHATBOT_CHANNEL")
            {

                if (extension_packet.type === "trigger_chatbotResponse")
                {
                    // these are responses from chatbot that got sent directly (ie not as chatbot chat functionality)
                    sr_api.sendMessage(DataCenterSocket,
                        sr_api.ServerPacket("ExtensionMessage",
                            serverConfig.extensionname,
                            sr_api.ExtensionPacket(
                                "action_SendChatMessage",
                                serverConfig.extensionname,
                                // need to read accounts from twitchchat ext and give an option to chose who to send the message as
                                {
                                    account: "bot",
                                    message: extension_packet.data.parameters.message,
                                    'message-type': "AIchatbotmessage"
                                },
                                "",
                                "twitchchat"),
                            "",
                            "twitchchat"
                        ));
                }
                else if (extension_packet.type === "serverError")
                {
                    parseTwitchChatMessage(extension_packet.data);
                    displayChatMessages();
                }
            }
            // -------------------------------------------------------------------------------------------------
            //                           UNHANDLED CHANNEL DATA
            // -------------------------------------------------------------------------------------------------
            else if (server_packet.dest_channel == "MSFS2020_CHANNEL"
                || server_packet.dest_channel == "USERS_CHANNEL"
            )
            {
                //just igore these messages
            }
            else
            {
                console.log(".onDataCenterMessage", "Channel Data " + server_packet.dest_channel + " not handled");
            }
        }
        // -------------------------------------------------------------------------------------------------
        //                           UNKNOWN CHANNEL MESSAGE RECEIVED
        // -------------------------------------------------------------------------------------------------
        else if (server_packet.type === "UnknownChannel")
        {
            //channel might not exist yet, extension might still be starting up so lets rescehuled the join attempt
            // need to add some sort of flood control here so we are only attempting to join one at a time
            if (server_packet.data != "" && server_packet.channel != undefined)
            {
                setTimeout(() =>
                {

                    sr_api.sendMessage(DataCenterSocket,
                        sr_api.ServerPacket(
                            "JoinChannel",
                            serverConfig.extensionname,
                            server_packet.data
                        ));
                }, 10000);
            }
        }
    }
    // ============================================================================
    //                           FUNCTION: deadMansHeartBeatCallback
    // ============================================================================
    // Description: started when we get a heartbeat and used to mark the extension as down if it expires
    // Parameters: extension name and the state (true fals to represent status)
    // ----------------------------- notes ----------------------------------------
    // none
    // ===========================================================================
    function deadMansHeartBeatCallback (extensionname)
    {
        setExtensionStatus(extensionname, false);
    }
    // ============================================================================
    //                           FUNCTION: SaveConfigToServer
    // ============================================================================
    function SaveConfigToServer ()
    {
        // saves our serverConfig to the server so we can load it again next time we startup
        sr_api.sendMessage(DataCenterSocket,
            sr_api.ServerPacket(
                "SaveConfig",
                serverConfig.extensionname,
                serverConfig,
            ));
    }
    // ============================================================================
    //                           FUNCTION: SaveDataToServer
    // ============================================================================
    // Description:save data on backend data store
    // Parameters: none
    // ----------------------------- notes ----------------------------------------
    // none
    // ===========================================================================
    function SaveDataToServer ()
    {
        sr_api.sendMessage(DataCenterSocket,
            sr_api.ServerPacket(
                "SaveData",
                serverConfig.extensionname,
                serverData));
    }
    // ============================================================================
    //                           FUNCTION: loadExtensionCards
    // ============================================================================
    // Description: display message in allmessages card
    // Parameters: list of extension names
    // ----------------------------- notes ----------------------------------------
    // There is a bug here. If the backend restarts and the page isn't 
    // refreshed then any callbacks from the froms will fail. fix was to 
    // force a fresh of the page when a new extension list comes in. Not very
    // smooth :(
    // ===========================================================================
    function loadExtensionCards (extensions)
    {
        extensions.sort()
        // First we create all the links (these may be changed below if the extension has provided a modal box)
        var html = "<div>";
        for (var i = 0; i < extensions.length; i++)
        {
            // if we dont currently have that extension add it to the list and request the code for its settings
            // displays if it has them (done via callbacks over the websocket)
            if (typeof livePortalVolatileData.extensions[extensions[i]] == "undefined")
            {
                livePortalVolatileData.extensions[extensions[i]] = {};
                livePortalVolatileData.extensions[extensions[i]].display = false;
                RequestSettingsWidgetSmallsCode(extensions[i]);
                RequestSettingsWidgetLargeCode(extensions[i]);

            }

            html += "<div id='" + extensions[i] + "_visibility_settingswidgetsmall' style='display: none;'> <span id='" + extensions[i] + "_status' class='extensioncardicon'>&#x2B24</span>";
            html += " <span id='" + extensions[i] + "_settingslinkname'>" + extensions[i] + "</span></div>";

        };
        //html += "</ul>";
        html += "</div>";
        document.getElementById("ExtensionsListCard").getElementsByClassName("card-title")[0].innerHTML = "ExtensionsList";
        document.getElementById("ExtensionsListCard").getElementsByClassName("card-text")[0].innerHTML = html;

        // lets check if we have a previous settingswidgets cards for this extension and if so add it to the link above
        for (var i = 0; i < extensions.length; i++)
        {
            if (livePortalVolatileData.extensions[extensions[i]].settingswidgetsmall)
                addSettingsWidgetSmall(extensions[i])
        }
        addALLSettingsWidgetLargeScheduler()

    }
    // ===========================================================================
    //                           FUNCTION: SendSettingsWidgetSmall
    // ===========================================================================
    // Description: Send the modal code back after setting the defaults according 
    // to our server settings
    // Parameters: channel to send data to
    // ----------------------------- notes ---------------------------------------
    // none
    // ===========================================================================
    function SendSettingsWidgetSmall (toextension)
    {
        let modalstring = livePortalVolatileData.extensions[serverConfig.extensionname].settingswidgetsmall;
        // first lets update our modal to the current settings
        for (const [key, value] of Object.entries(serverConfig))
        {
            // true values represent a checkbox so replace the "[key]checked" values with checked
            if (value === "on")
                modalstring = modalstring.replaceAll(key + "_SettingsSmallFormItemchecked", "checked");
            else if (typeof (value) == "string" || typeof (value) == "number")
                modalstring = modalstring.replaceAll('"' + key + '_SettingsSmallFormItemtext"', '"' + value + '"');
        }
        // send the modal data to the server
        // send the modal data to the server
        sr_api.sendMessage(DataCenterSocket,
            sr_api.ServerPacket(
                "ExtensionMessage",
                serverConfig.extensionname,
                sr_api.ExtensionPacket(
                    "SettingsWidgetSmallCode",
                    serverConfig.extensionname,
                    modalstring,
                    serverConfig.channel,
                    toextension
                ),
                serverConfig.channel,
                toextension
            ));
    }
    // ===========================================================================
    //                           FUNCTION: SendSettingsWidgetLarge
    // ===========================================================================
    // Description: Send the modal code back after setting the defaults according 
    // to our server settings
    // Parameters: channel to send data to
    // ----------------------------- notes ---------------------------------------
    // none
    // ===========================================================================
    function SendSettingsWidgetLarge (toextension)
    {
        let modalstring = livePortalVolatileData.extensions[serverConfig.extensionname].settingswidgetlarge;
        // first lets update our modal to the current settings
        for (const [key, value] of Object.entries(serverConfig))
        {
            // true values represent a checkbox so replace the "[key]checked" values with checked
            if (value === "on")
                modalstring = modalstring.replaceAll(key + "checked", "checked");
            else if (typeof (value) == "string" || typeof (value) == "number")
                modalstring = modalstring.replaceAll('"' + key + 'text"', '"' + value + '"');
        }
        // send the modal data to the server
        // send the modal data to the server
        sr_api.sendMessage(DataCenterSocket,
            sr_api.ServerPacket(
                "ExtensionMessage",
                serverConfig.extensionname,
                sr_api.ExtensionPacket(
                    "SettingsWidgetLargeCode",
                    serverConfig.extensionname,
                    modalstring,
                    serverConfig.channel,
                    toextension
                ),
                serverConfig.channel,
                toextension
            ));
    }
    // ============================================================================
    //                           FUNCTION: addSettingsWidgetSmall
    // ============================================================================
    // Description: Add the modal code from the extension to the link
    // Parameters: 
    //          xname - name of extension
    //          data  - data to add
    // ----------------------------- notes ----------------------------------------
    // None
    // ===========================================================================
    function addSettingsWidgetSmall (xname)
    {
        // only update modals if we have received the extension name from the server
        if (livePortalVolatileData.extensions[xname])
        {
            let wasVisible = false;
            // hide the modal before replacing it (in case it is currently visable).
            if ($('#' + xname + "_settingswidgetsmallmodal").hasClass('show'))
                wasVisible = true
            $('#' + xname + "_settingswidgetsmallmodal").modal("hide")

            let data = livePortalVolatileData.extensions[xname].settingswidgetsmall
            // grab the placeholder code we user to save us from writing all the code from scratch :P
            let modalbox = document.getElementById("LivePortalSettingsWidgetsSmallPlaceholder").children[0];
            // check we have a visibity link, if not we don't have a container for this model to go in
            if (document.getElementById(xname + "_visibility_settingswidgetsmall") == null)
                return
            document.getElementById(xname + "_visibility_settingswidgetsmall").style.display = "";

            // grab the <li> element for this extension added in when we got the extension list
            let extLiTag = document.getElementById(xname + "_settingslinkname");


            // remove the previous event listener (if there was one)
            $('#' + xname + "_settingswidgetsmallmodal").off('submit');

            //load the modal data we have been sent into the tag
            extLiTag.innerHTML = modalbox.innerHTML;
            // setup the link to show the dialog
            extLiTag.getElementsByClassName("ext-modal-link")[0].href = "#" + xname + "_settingswidgetsmallmodal";
            extLiTag.getElementsByClassName("ext-modal-link")[0].innerHTML = xname;
            extLiTag.getElementsByClassName("modal")[0].id = xname + "_settingswidgetsmallmodal";

            extLiTag.innerHTML = extLiTag.innerHTML + "<a href='https://github.com/SilenusTA/StreamRoller/blob/master/extensions/" + xname + "/README.md' Title='" + xname + " docs' target='readme'><img src='/liveportal/images/info.png' width='15px' height='15px'></a>"

            // set the data from the extension
            document.getElementById(xname + "_settingswidgetsmallmodal").innerHTML = data;

            // add a callback handle when form is submitted
            $('#' + xname + "_settingswidgetsmallmodal").on('submit', function (event)
            {
                event.preventDefault();
                // if it is our own modal that has changed (another page has submitted one)
                // we need to process it ourselves first
                if (xname == serverConfig.extensionname)
                {
                    // process this data oursleves first
                    processOwnSettingsWidgetSmallSubmit(xname);
                    // now it is processed we can parse it
                    UpdateOwnSettingsWidgetSmallData()
                    UpdateOwnSettingsWidgetLargeData()

                    // update anyone that has our modal
                    SendSettingsWidgetSmall("");
                    SendSettingsWidgetLarge("");

                    ParseOBSScenesList(localConfig.OBSSceneslist);
                    setCardsVisibility();
                }
                else
                    parseExtensionModalData(xname, xname + "_settingswidgetsmallmodal");
                return false;
            });
            document.getElementById(xname + "_visibility_settingswidgetsmall").style.display = "block"
            // if this modal was open when we got the update then reopen it for the user
            if (wasVisible)
                $('#' + xname + "_settingswidgetsmallmodal").modal("show")

        }
        // need to update the mode in case we have received a light mode 
        // modal and we are in dark mode
        refreshDarkMode();
    }
    // ============================================================================
    //                           FUNCTION: addALLSettingsWidgetLargeScheduler
    // ============================================================================
    // buffers widget being set.
    function addALLSettingsWidgetLargeScheduler ()
    {
        // CACHE REQUESTS
        // already a scheduler waiting so clear it and restart (cahching requests)
        if (localConfig.LargeSettingsDataCacheHandle != null)
        {
            // clear the existing timer as we have a new update
            clearTimeout(localConfig.LargeSettingsDataCacheHandle)
            localConfig.LargeSettingsDataCacheHandle == null
        }

        // set the timeout
        localConfig.LargeSettingsDataCacheHandle = setTimeout(() =>
        {
            // last run is still going 
            if (localConfig.addALLSettingsWidgetLargeRunning)
            {
                // reschedule this run when the current running timer has finished
                localConfig.LargeSettingsDataCacheHandle = null;
                setTimeout(() =>
                {
                    addALLSettingsWidgetLargeScheduler();
                }, 100);

            }
            else
            {
                addALLSettingsWidgetLarge();
                localConfig.LargeSettingsDataCacheHandle == null
            }
        }, localConfig.LargeSettingsDataCacheTimeout);
    }
    // ============================================================================
    //                           FUNCTION: addSettingsWidgetLarge
    // ============================================================================
    // Description: Add the modal code from the extension
    // Parameters: 
    //          xname - name of extension
    //          data  - data to add
    // ----------------------------- notes ----------------------------------------
    // None
    // ===========================================================================
    function addALLSettingsWidgetLarge ()
    {
        if (localConfig.addALLSettingsWidgetLargeRunning)
            return;
        localConfig.addALLSettingsWidgetLargeRunning = true;
        let first = true;
        // clear the existing page data
        document.getElementById("SettingsPageTabs").innerHTML = "";
        document.getElementById("SettingsPageContent").innerHTML = "";
        // add/replace the existing data for this extensions
        // loop through all our extensions and add them to the tabs and insert the widget in to the page

        Object.entries(livePortalVolatileData.extensions).forEach(([xname, stuff]) =>
        {
            if (stuff.settingswidgetlarge)
            {
                // ################# ADD TABS ##############
                if (first)
                {
                    document.getElementById("SettingsPageTabs").innerHTML += "<li class='nav-item' id='" + xname + "_settingswidgetlargetab'>\n<a class='nav-link active bg-light text-dark' id='" + xname + "_settingswidgetlargelink' data-toggle='tab' href='#" + xname + "_settingswidgetlargecontent'>" + xname + "</a>\n</li>"
                }
                else
                    document.getElementById("SettingsPageTabs").innerHTML += "<li class='nav-item' id='" + xname + "_settingswidgetlargetab'>\n<a class='nav-link bg-light text-dark' id='" + xname + "_settingswidgetlargelink' data-toggle='tab' href='#" + xname + "_settingswidgetlargecontent'>" + xname + "</a>\n</li>"

                // ################# ADD Content ##############
                if (first)
                {
                    first = false;
                    document.getElementById("SettingsPageContent").innerHTML += "<div class='tab-pane fade show active' role='tabpanel'  id='" + xname + "_settingswidgetlargecontent'>" + stuff.settingswidgetlarge + "</div>"
                }
                else
                    document.getElementById("SettingsPageContent").innerHTML += "<div class='tab-pane fade' role='tabpanel' id='" + xname + "_settingswidgetlargecontent'>" + stuff.settingswidgetlarge + "</div>"

                setTimeout(() =>
                {
                    $('#' + xname + "_settingsform").off('submit');
                    $('#' + xname + "_settingsform").on('submit', function (event)
                    {
                        event.preventDefault();
                        // if it is our own modal that has changed (another page has submitted one
                        // we need to process it ourselves first
                        if (xname == serverConfig.extensionname)
                        {
                            // process this data oursleves first
                            processOwnSettingsWidgetLargeSubmit(xname);
                            // now it is processed we can parse it
                            UpdateOwnSettingsWidgetSmallData()
                            UpdateOwnSettingsWidgetLargeData()

                            // update anyone that has our modal
                            SendSettingsWidgetSmall("");
                            SendSettingsWidgetLarge("");

                            ParseOBSScenesList(localConfig.OBSSceneslist);
                            setCardsVisibility();
                        }
                        else
                            parseExtensionModalData(xname, xname + "_settingsform");

                        $("#live-tab").tab('show');
                        return false;
                    });
                    $('#' + xname + "_settingsform").find('#closeSettings' + xname).on('click', function (event)
                    {
                        event.preventDefault();
                        $("#live-tab").tab('show');
                        return false;
                    });

                    // Extract and execute script tags
                    // For this we need to copy the script out of the file sent to us and then 
                    // re-attach it to the page so that the script can be loaded (as scripts only get loaded when 
                    // the page is loaded they don't work if added later unless re-attached)
                    // If this is an update we also need to remove the previous script we added
                    let modalElement = document.getElementById(xname + "_settingswidgetlargecontent")
                    const scripts = modalElement.querySelectorAll('script');
                    scripts.forEach((script) =>
                    {
                        // create a new id for this script
                        let scriptname = xname + "_settingswidgetlargecontentscript"
                        // check if we already have a script of this name (it is a page refresh)
                        let previouslyAddedScript = document.getElementById(scriptname)
                        if (previouslyAddedScript)
                            // remove existing script
                            previouslyAddedScript.remove();
                        // remove the script from the incoming page
                        script.remove();
                        const newScript = document.createElement('script');
                        newScript.id = scriptname
                        try
                        {
                            if (script.src) // External script
                            {
                                newScript.src = script.src;
                                document.body.appendChild(newScript);
                            } else // Inline script
                            {
                                newScript.textContent = "//Added by liveportal " + script.textContent
                                document.body.appendChild(newScript);
                            }
                        }
                        catch (err)
                        {
                            console.log("Error enabling script", err)
                        }
                    });
                    localConfig.addALLSettingsWidgetLargeRunning = false;
                }, 200);
            }
        });

        setTimeout(() =>
        {
            $('#SettingsPageTabs a').off('click')
            $('#SettingsPageTabs a').click(function (e)
            {
                e.preventDefault();
                $(this).tab('show');
            })
            // need to update the mode in case we have received a light mode 
            // modal and we are in dark mode, done here in case we arn't loaded yet
            refreshDarkMode();

        }, 200);

    }
    // ============================================================================
    //                           FUNCTION: setExtensionStatus
    // ============================================================================
    function setExtensionStatus (extension, status)
    {
        /* extensions can send vaious data here. The priority is
        1) if they provide a color just use that
        2) if they are not connected or status is false set red // backwards compatability here
        3) if they have a readonly flag set to true set orange // for chat mostly
        4) if connected or status is true set green
        5) otherwise set red
 
        */
        //checking for old heartbeat message types. should be all fixed
        if ((typeof (status)) != "object")
        {
            if (!status || status == false || status == "false")
                document.getElementById(extension + "_status").style = "color:red";
            else
                document.getElementById(extension + "_visibility_settingswidgetsmall").style.display = "";
        }
        else if (!status)
        {
            document.getElementById(extension + "_status").style = "color:red";
        }
        else if (status.color)
            document.getElementById(extension + "_status").style = "color:" + status.color;
        else if (status.connected && status.connected == "false")// string
        {
            document.getElementById(extension + "_status").style = "color:red";
        }
        else if (status.readonly || status.readonly == "true")//chat connection settings
            document.getElementById(extension + "_status").style = "color:orange";
        else if (status.connected || status.connected == "true")
            document.getElementById(extension + "_status").style = "color:green";
        else
            document.getElementById(extension + "_status").style = "color:red";
        document.getElementById(extension + "_visibility_settingswidgetsmall").style.display = "";
    }
    // ============================================================================
    //                           FUNCTION: UpdateOBSDefaultButtons
    // ============================================================================
    function UpdateOBSDefaultButtons ()
    {
        var element = document.getElementById("OBSDefaultButtons");
        element.textContent = "";

        if (localConfig.timers.StartCountdownTimer != undefined && localConfig.timers.StartCountdownTimer > 0)
        {
            let minutes = Math.floor(localConfig.timers.StartCountdownTimer / 60);
            let seconds = localConfig.timers.StartCountdownTimer - (minutes * 60);
            addOBSSceneButton(element, "Start", serverConfig.obsdefaultstartscenename, localConfig.OBSSceneslist.current, minutes.toString().padStart(2, '0') + ":" + seconds.toString().padStart(2, '0'))
        }
        else
            addOBSSceneButton(element, "Start", serverConfig.obsdefaultstartscenename, localConfig.OBSSceneslist.current)
        addOBSSceneButton(element, "Live", serverConfig.obsdefaultlivescenename, localConfig.OBSSceneslist.current)
        addOBSSceneButton(element, "Intermission", serverConfig.obsdefaultintermissionscenename, localConfig.OBSSceneslist.current)
        addOBSSceneButton(element, "End", serverConfig.obsdefaultendscenename, localConfig.OBSSceneslist.current)
    }
    // ============================================================================
    //                           FUNCTION: UpdateOBSCountdownTimer
    // ============================================================================
    function UpdateOBSCountdownTimer ()
    {
        var element = document.getElementById("OBSDefaultButtons");
        if (localConfig.timers.StartCountdownTimer != undefined)
        {
            if (localConfig.timers.StartCountdownTimer > 0)
            {
                let minutes = Math.floor(localConfig.timers.StartCountdownTimer / 60);
                let seconds = localConfig.timers.StartCountdownTimer - (minutes * 60);
                var startButton = element.querySelector("#Start")
                startButton.value = minutes.toString().padStart(2, '0') + ":" + seconds.toString().padStart(2, '0');
            }
            else
                // reset all buttons when the timer ends
                UpdateOBSDefaultButtons()
        }
    }
    // ============================================================================
    //                           FUNCTION: ParseOBSScenesList
    // ============================================================================
    function ParseOBSScenesList (data)
    {
        let primaryScenes = data.main;
        let secondaryScenes = data.secondary;
        let restScenes = data.rest;
        let foundmutedscene = false;
        // remove the existing buttons
        var element = document.getElementById("OBSButtons");
        //remove the old buttons
        element.textContent = ""
        //store the data incase the user updated what they want to display
        localConfig.OBSSceneslist = data;
        // update default buttons
        UpdateOBSDefaultButtons();

        // always show the primary scene list
        if (typeof (primaryScenes) !== "undefined" &&
            (serverConfig.showallscenes === "on" || serverConfig.showprimaryscenes === "on")
        )
        {
            primaryScenes.forEach((scene) => 
            {
                addOBSSceneButton(element, scene.displayName, scene.sceneName, data.current);
                if (scene.displayName === serverConfig.mutescene)
                {
                    foundmutedscene = true;
                    addOBSMuteButton(scene.muted);
                }
            });
        }
        // if we have all or secondory selected to show then show both 'secondary' list and 'rest' list
        if (typeof (secondaryScenes) !== "undefined" && (serverConfig.showallscenes === "on" || serverConfig.showsecondaryscenes === "on"))
        {
            secondaryScenes.forEach((scene) => 
            {
                addOBSSceneButton(element, scene.displayName, scene.sceneName, data.current);
                if (scene.displayName === serverConfig.mutescene)
                {
                    foundmutedscene = true;
                    addOBSMuteButton(scene.muted);
                }
            });
        }
        // only show remaining scenes if all is set
        if (typeof (restScenes) !== "undefined" && serverConfig.showallscenes === "on")
        {
            restScenes.forEach((scene) => 
            {
                addOBSSceneButton(element, scene.displayName, scene.sceneName, data.current)
                if (scene.displayName === serverConfig.mutescene)
                {
                    foundmutedscene = true;
                    addOBSMuteButton(scene.muted);
                }
            })
            // Add mute button
        }
        if (!foundmutedscene)
            addOBSMuteButton(serverConfig.muted);
        // check if we are live and set the colors accordingly.
        OBSLiveCheck();
        //update any filters we may have
        UpdateOBSFilters();
    }
    // ============================================================================
    //                           FUNCTION: addOBSSceneButton
    // ============================================================================
    function addOBSSceneButton (element, displayname, scenename, current, alternateValue = displayname)
    {
        let button = document.createElement('input');
        if (localConfig.ClickHighlightTimer)
            clearTimeout(localConfig.ClickHighlightTimer);
        button.type = 'button';
        button.id = displayname;
        button.value = alternateValue;
        if (scenename === current)
            button.classList = "btn btn-success";
        else
            button.classList = "btn btn-secondary";
        button.addEventListener('click', function ()
        {
            button.classList = "btn btn-warning"
            localConfig.ClickHighlightTimer = setTimeout(() =>
            {
                if (scenename === current)
                    button.classList = "btn btn-success";
                else
                    button.classList = "btn btn-secondary";
            }, 1000)
            event.preventDefault();
            sr_api.sendMessage(DataCenterSocket,
                sr_api.ServerPacket(
                    "ExtensionMessage",
                    serverConfig.extensionname,
                    sr_api.ExtensionPacket(
                        "action_ChangeScene",
                        serverConfig.extensionname,
                        scenename,
                        "",
                        "obs"
                    ),
                    "",
                    "obs"
                )
            )
            return false;
        }, false);

        element.appendChild(button);
    }
    // ============================================================================
    //                           FUNCTION: addOBSMuteButton
    // ============================================================================
    function addOBSMuteButton (muted)
    {
        let button = document.createElement('input');
        button.type = 'button';
        button.value = "Mute";
        if (muted)
            button.classList += "btn btn-danger";
        else
            button.classList += "btn btn-secondary";
        button.addEventListener('click', function ()
        {
            event.preventDefault();
            sr_api.sendMessage(DataCenterSocket,
                sr_api.ServerPacket(
                    "ExtensionMessage",
                    serverConfig.extensionname,
                    sr_api.ExtensionPacket(
                        "action_ToggleMute",
                        serverConfig.extensionname,
                        { sourceName: serverConfig.mutescene },
                        "",
                        "obs"
                    ),
                    "",
                    "obs"
                )
            )
            return false;
        }, false);

        //remove the old button
        document.getElementById("OBSMute").textContent = ""
        // add the new one
        document.getElementById("OBSMute").appendChild(button);
    }
    // ============================================================================
    //                           FUNCTION: OBSLiveCheck
    // ============================================================================
    function OBSLiveCheck ()
    {
        let livebackbround = document.getElementById("OBSControllsCard");
        // check if we are live
        if (localConfig.obslive)
        {
            // currently set to live so lets set the background to green
            // remove the normal colors
            livebackbround.classList.remove('bg-light');
            livebackbround.classList.remove('text-light');
            livebackbround.classList.remove('bg-dark');
            livebackbround.classList.remove('text-dark');
            livebackbround.style["background-color"] = "#013301";
            livebackbround.style["color"] = "white";
            // remove any previous colors for the background
        }
        else
        {
            // not live anymore so set the background back to normal
            document.getElementById("OBSStrain").style.removeProperty("background-color")
            // background is set in the navbar partial code and uses local storage. should probably update this and move it here
            if (localStorage.getItem("darkmode") === "true")
            {
                livebackbround.classList.remove('bg-light');
                livebackbround.classList.remove('text-dark');
                livebackbround.classList.add('bg-dark');
                livebackbround.classList.add('text-light');
            }
            else
            {
                livebackbround.classList.remove('bg-dark');
                livebackbround.classList.remove('text-light');
                livebackbround.classList.add('bg-light');
                livebackbround.classList.add('text-dark');
            }
        }
    }
    // ============================================================================
    //                           FUNCTION: ProcessOBSStats
    // ============================================================================
    // Description:save config on backend data store
    // Parameters: none
    // ----------------------------- notes ----------------------------------------
    // 
    /*{
  "averageFrameTime": 24.81013,
  "bytesPerSec": 60795,
  "cpuUsage": 18.0699481865285,
  "freeDiskSpace": 348106.8203125,
  "kbitsPerSec": 474,
  "memoryUsage": 468.78125,
  "numDroppedFrames": 0,
  "numTotalFrames": 44,
  "outputSkippedFrames": 0,
  "outputTotalFrames": 57,
  "previewOnly": false,
  "recordingPaused": false,
  "renderMissedFrames": 4,
  "renderTotalFrames": 2932,
  "replayBufferActive": false,
  "streamTimecode": "00:00:01.466",
  "totalStreamTime": 1,
  "updateType": "StreamStatus"
  */

    // ===========================================================================
    function ProcessOBSStats (data)
    {
        var hour = "";
        var min = "";
        var sec = "";
        var Uptime = "";
        var missedframestxt = "";
        var skippedframestxt = "";

        if (localConfig.obslive)
        {
            //let rate = data.outputBytes;
            let strain = data.outputCongestion; // red/green/amber icon needed
            var straincolor = (255 / 1 * strain);
            var Uptime = "";

            // saves our serverConfig to the server so we can load it again next time we startup
            if (data.totalStreamTime > 0)
            {
                hour = Math.floor((data.totalStreamTime / 1000 / 3600) << 0)
                min = Math.floor((data.totalStreamTime / 1000 / 60) << 0)
                sec = Math.floor((data.totalStreamTime / 1000) % 60);
                if (hour > 0)
                    Uptime = "Uptime:<BR>" + hour + ":" + (min - (hour * 60)) + ":" + sec
                else
                    Uptime = "Uptime:<BR>" + hour + ":" + min + ":" + sec
            }

            document.getElementById("OBSUptime").innerHTML = Uptime;
            //document.getElementById("OBSRate").innerHTML = "Rate:<BR>" + rate + " kb/s";

            let missedframes = data.renderSkippedFrames;
            let skippedframes = data.outputSkippedFrames;
            // add coloring if we drop too many frames and we also truncat the numbers if over 10k
            if (missedframes > 1000)
            {
                if (missedframes > 1000)
                    missedframestxt = (~~(missedframes / 1000)) + "k"
                missedframestxt = "<span style='color:red'>Render errors:<BR>" + missedframestxt + "</span>";
            }
            else if (missedframes > 0)
                missedframestxt = "<span style='color:orange'>Render errors:<BR>" + missedframes + "</span>";
            else
                missedframestxt = "<span style='color:green'>Render errors:<BR>" + missedframes + "</span>";

            if (skippedframes > 1000)
            {
                if (skippedframes > 10000)
                    skippedframestxt = (~~(skippedframes / 1000)) + "k"
                skippedframestxt = "<span style='color:red'>Network frames errors:<BR>" + skippedframestxt + "</span>";
            }
            else if (skippedframes > 0)
                skippedframestxt = "<span style='color:orange'>Network frames errors:<BR>" + skippedframes + "</span>";
            else
                skippedframestxt = "<span style='color:green'>Network frames errors:<BR>" + skippedframes + "</span>";

            // note the double not (~) removes the decimal part more efficiently than the match.trunc fungion
            if (data.renderTotalFrames > 1000)
                document.getElementById("OBSRender").innerHTML = missedframestxt + "/" + (~~(data.renderTotalFrames / 1000)) + "k";
            else
                document.getElementById("OBSRender").innerHTML = missedframestxt + "/" + data.renderTotalFrames;
            if (data.outputTotalFrames > 1000)
                document.getElementById("OBSNetwork").innerHTML = skippedframestxt + "/" + (~~(data.outputTotalFrames / 1000)) + "k";
            else
                document.getElementById("OBSNetwork").innerHTML = skippedframestxt + "/" + data.outputTotalFrames;

            document.getElementById("OBSStrain").style["background-color"] = "rgb(" + straincolor + "," + (255 - straincolor) + ",0)";
        }
    }
    // ============================================================================
    //                           FUNCTION: UpdateOBSFilters
    // ============================================================================
    function UpdateOBSFilters ()
    {
        if (localConfig.OBSSceneslist)
        {
            let currentscene = localConfig.OBSSceneslist.current
            let element = document.getElementById("OBSFiltersRow");
            element.textContent = "";
            // need to find our scene to retrieve the filter list. who designed this structure ffs, I must have been drunk
            for (const entry in localConfig.OBSSceneslist.main) 
            {
                if (localConfig.OBSSceneslist.main[entry].sceneName === currentscene)
                {
                    if (localConfig.OBSSceneslist.main[entry].filters)
                        localConfig.OBSSceneslist.main[entry].filters.forEach((filter) =>
                            addOBSFilterButton(element, filter.filterName, localConfig.OBSSceneslist.current, filter.filterEnabled)
                        );
                    return
                }
            }
            for (const entry in localConfig.OBSSceneslist.secondary) 
            {
                if (localConfig.OBSSceneslist.secondary[entry].sceneName === currentscene)
                {
                    if (localConfig.OBSSceneslist.secondary[entry].filters)
                        localConfig.OBSSceneslist.secondary[entry].filters.forEach((filter) =>
                            addOBSFilterButton(element, filter.filterName, localConfig.OBSSceneslist.current, filter.filterEnabled)
                        );
                    return
                }
            }
            for (const entry in localConfig.OBSSceneslist.rest) 
            {
                if (localConfig.OBSSceneslist.rest[entry].sceneName === currentscene)
                {
                    if (localConfig.OBSSceneslist.rest[entry].filters)
                        localConfig.OBSSceneslist.rest[entry].filters.forEach((filter) =>
                            addOBSFilterButton(element, filter.filterName, localConfig.OBSSceneslist.current, filter.filterEnabled)
                        );
                    return
                }
            }
        }
    }
    // ============================================================================
    //                           FUNCTION: addOBSFilterButton
    // ============================================================================
    function addOBSFilterButton (element, displayname, scenename, enabled)
    {
        let button = document.createElement('input');
        button.type = 'button';
        button.value = displayname;
        if (enabled)
            button.classList = "btn btn-sm btn-success mx-1";
        else
            button.classList = "btn btn-sm btn-secondary mx-1";
        button.addEventListener('click', function ()
        {
            event.preventDefault();
            sr_api.sendMessage(DataCenterSocket,
                sr_api.ServerPacket(
                    "ExtensionMessage",
                    serverConfig.extensionname,
                    sr_api.ExtensionPacket(
                        "action_ToggleFilter",
                        serverConfig.extensionname,
                        {
                            sourceName: scenename,//"#4x3_Cam",
                            filterName: displayname, //"mycolorCorrection",
                            filterEnabled: !enabled //false
                        },
                        "",
                        "obs"
                    ),
                    "",
                    "obs"
                )
            )
            return false;
        }, false);

        element.appendChild(button);
    }
    // ============================================================================
    //                      FUNCTION: parseExtensionModalData
    // ============================================================================
    // Description: This function will retireve the data from the modal and 
    // send the push the data out so others can update theirs to reflect the change
    // Parameters: none
    // ----------------------------- notes ----------------------------------------
    // None
    // ===========================================================================
    function parseExtensionModalData (extension, page_id)
    {
        let fieldsAsArray = $('#' + page_id).serializeArray();
        // convert our array of objects into a more usable objet
        var fieldsAsObject = fieldsAsArray.reduce((obj, item) => (obj[item.name] = item.value, obj), {});

        if (fieldsAsObject.extensionname)
            sr_api.sendMessage(DataCenterSocket,
                sr_api.ServerPacket(
                    "ExtensionMessage",
                    serverConfig.extensionname,
                    sr_api.ExtensionPacket(
                        fieldsAsObject.modaldatatype,
                        serverConfig.extensionname,
                        fieldsAsObject,
                        "",
                        fieldsAsObject.extensionname),
                    "",
                    fieldsAsObject.extensionname
                ));

    }
    // ============================================================================
    //                      FUNCTION: UpdateOwnSettingsWidgetSmallData
    // ============================================================================
    // Description: Update our own modal if our config has changed
    // Parameters: none
    // ----------------------------- notes ----------------------------------------
    // 
    // ===========================================================================
    function UpdateOwnSettingsWidgetSmallData ()
    {
        //get our widget and use string replace to update the values
        let modalstring = livePortalVolatileData.extensions[serverConfig.extensionname].settingswidgetsmall_placeholder


        // voice list updates
        //update voices if we don't have any yet
        if (!localConfig.TTSVoiceList.length)
            LoadVoices();

        //update TTS section
        if (localConfig.TTSVoiceList.length)
        {
            let twitchoptioncode = "";
            let ytoptioncode = "";
            let testoptioncode = "";
            // check if we have anything selected, if not set a default option
            if (serverConfig.twitchTTSVoiceIndex != -1)
                twitchoptioncode += "<option value='-1' selected>Please Select a Voice</option>"
            if (serverConfig.YouTubeTTSVoiceIndex != -1)
                ytoptioncode += "<option value='-1' selected>Please Select a Voice</option>"
            testoptioncode += "<option value='-1' selected>Please Select a Voice</option>"

            // make up the list for each dropdown
            localConfig.TTSVoiceList.forEach((voice, index) =>
            {
                if (index == serverConfig.twitchTTSVoiceIndex)
                    twitchoptioncode += "<option value='" + index + "' selected>" + voice.name.replace(/^(Microsoft\.*)/, "") + "LoadVoiceTimer</option>"
                else
                    twitchoptioncode += "<option value='" + index + "'>" + voice.name.replace(/^(Microsoft\.*)/, "") + "</option>"

                if (index == serverConfig.YouTubeTTSVoiceIndex)
                    ytoptioncode += "<option value='" + index + "' selected>" + voice.name.replace(/^(Microsoft\.*)/, "") + "LoadVoiceTimer</option>"
                else
                    ytoptioncode += "<option value='" + index + "'>" + voice.name.replace(/^(Microsoft\.*)/, "") + "</option>"
                testoptioncode += "<option value='" + index + "'>" + voice.name.replace(/^(Microsoft\.*)/, "") + "</option>"
            });
            //update the modal boxes for each platform and the test button
            modalstring = modalstring.replaceAll("TwitchTTSVoicesReplacedInUpdateOwnSettingsWidgetSmallData", twitchoptioncode);
            modalstring = modalstring.replaceAll("YouTubeTTSVoicesReplacedInUpdateOwnSettingsWidgetSmallData", ytoptioncode);
            modalstring = modalstring.replaceAll("TestVoiceTTSVoicesReplacedInUpdateOwnSettingsWidgetSmallData", testoptioncode);
        }
        else
        {
            let noVoicesOption = '<option value="Microsoft George - English (United Kingdom)" selected>Loading ...</option>'
            modalstring = modalstring.replaceAll("TwitchTTSVoicesReplacedInUpdateOwnSettingsWidgetSmallData", noVoicesOption);
            modalstring = modalstring.replaceAll("YouTubeTTSVoicesReplacedInUpdateOwnSettingsWidgetSmallData", noVoicesOption);
            modalstring = modalstring.replaceAll("TestVoiceTTSVoicesReplacedInUpdateOwnSettingsWidgetSmallData", noVoicesOption);
        }

        // other data update
        for (const [key, value] of Object.entries(serverConfig))
        {
            // checkboxes
            if (value === "on")
                modalstring = modalstring.replaceAll(' ' + key + '_SettingsSmallFormItemchecked', 'checked');
            else if (key === "randomfactstimeout")
                modalstring = modalstring.replaceAll('"' + key + '_SettingsSmallFormItemtext"', '"' + (value / 60000) + '"');
            // replace text strings
            else if (typeof (value) == "string" || typeof (value) == "number")
                modalstring = modalstring.replaceAll('"' + key + '_SettingsSmallFormItemtext', '"' + value);
        }
        livePortalVolatileData.extensions[serverConfig.extensionname].settingswidgetsmall = modalstring;
        // Update the OBS channel list as we might have changed what we want to show
        addSettingsWidgetSmall(serverConfig.extensionname, modalstring)

    }
    // ============================================================================
    //                      FUNCTION: UpdateOwnSettingsWidgetLargeData
    // ============================================================================
    // Description: Update our own modal if our config has changed
    // Parameters: none
    // ----------------------------- notes ----------------------------------------
    // 
    // ===========================================================================
    function UpdateOwnSettingsWidgetLargeData ()
    {

        //get our widget and use string replace to update the values
        let modalstring = livePortalVolatileData.extensions[serverConfig.extensionname].settingswidgetlarge_placeholder
        for (const [key, value] of Object.entries(serverConfig))
        {
            // checkboxes
            if (value === "on")
                modalstring = modalstring.replaceAll(' ' + key + 'checked', 'checked');
            else if (key === "randomfactstimeout") // change random facts to seconds from milliseconds
                modalstring = modalstring.replaceAll('"' + key + 'text"', '"' + (value / 60000) + '"');
            // replace text strings
            else if (typeof (value) == "string" || typeof (value) == "number")
                modalstring = modalstring.replaceAll('"' + key + 'text', '"' + value);
        }
        livePortalVolatileData.extensions[serverConfig.extensionname].settingswidgetlarge = modalstring;
        //document.getElementById(serverConfig.extensionname + "_settingswidgetlargemodal").innerHTML = modalstring;
        // Update the OBS channel list as we might have changed what we want to show

        // re-add the widge so it is updated on screen
        addALLSettingsWidgetLargeScheduler()

    }
    // ============================================================================
    //                      FUNCTION: processOwnSettingsWidgetSmallSubmit
    // ============================================================================
    // Description: This function will retireve the data from the modal and 
    // send save it in the serverConfig after we hit the submit button
    // Parameters: none
    // ----------------------------- notes ----------------------------------------
    // None
    // ===========================================================================
    function processOwnSettingsWidgetSmallSubmit (name)
    {
        // get the modal data as an array
        let fieldsAsArray = $('#' + name + "_settingswidgetsmallmodal").serializeArray();
        // convert our array of objects into a more usable object
        var fieldsAsObject = fieldsAsArray.reduce((obj, item) => (obj[item.name.replace("_SettingsSmallFormItem", "")] = item.value, obj), {});
        // loop though our keys and set them to match what is in the modal
        for (const [key, value] of Object.entries(serverConfig))
        {
            if (key == "TTSVoiceFilter" && fieldsAsObject[key] != value)
            {
                serverConfig.TTSVoiceFilter = fieldsAsObject[key]
                //data has changed
                LoadVoices()
            }

            if (key === "randomfactstimeout")
                serverConfig[key] = fieldsAsObject[key] * 60000
            // need to explicity check for checkboxes we have that are turned off (no data returned)
            // portal areas to show
            else if (key === "streamersonglistdisplay" && !fieldsAsObject[key])
                serverConfig[key] = "off";
            else if (key === "discordmodchatdisplay" && !fieldsAsObject[key])
                serverConfig[key] = "off";
            else if (key === "obsdisplay" && !fieldsAsObject[key])
                serverConfig[key] = "off";
            else if (key === "philipshuedisplay" && !fieldsAsObject[key])
                serverConfig[key] = "off";
            else if (key === "macrobuttonsdisplay" && !fieldsAsObject[key])
                serverConfig[key] = "off";
            else if (key === "slalertsdisplay" && !fieldsAsObject[key])
                serverConfig[key] = "off";
            //OBS buttons to show
            else if (key === "showprimaryscenes" && !fieldsAsObject[key])
                serverConfig[key] = "off";
            else if (key === "showsecondaryscenes" && !fieldsAsObject[key])
                serverConfig[key] = "off";
            else if (key === "showallscenes" && !fieldsAsObject[key])
                serverConfig[key] = "off";
            else if (key === "randomfactsenabled" && !fieldsAsObject[key])
                serverConfig[key] = "off";
            else if (key === "winttstwitchenabled" && !fieldsAsObject[key])
                serverConfig[key] = "off";
            else if (key === "winttsyoutubeenabled" && !fieldsAsObject[key])
                serverConfig[key] = "off";
            else if (key in fieldsAsObject)
                serverConfig[key] = fieldsAsObject[key];
        }
        //save the data to the server
        SaveConfigToServer();
    }
    // ============================================================================
    //                      FUNCTION: processOwnSettingsWidgetLargeSubmit
    // ============================================================================
    // Description: This function will retireve the data from the modal and 
    // send save it in the serverConfig after we hit the submit button
    // Parameters: none
    // ----------------------------- notes ----------------------------------------
    // None
    // ===========================================================================
    function processOwnSettingsWidgetLargeSubmit (name)
    {
        // get the modal data as an array
        let fieldsAsArray = $('#' + name + "_settingsform").serializeArray();
        // convert our array of objects into a more usable object
        var fieldsAsObject = fieldsAsArray.reduce((obj, item) => (obj[item.name] = item.value, obj), {});

        // check for restore defaults being hit
        if (fieldsAsObject.liveportal_restore_defaults == "on")
        {
            serverConfig = structuredClone(default_serverConfig);
            serverData = structuredClone(default_serverData);
            changeServerLogging(serverConfig.logginglevel);
            changeDiscordListeningChannel(serverConfig.modmessage_channel)
            return;
        }
        else
        {
            if (fieldsAsObject.liveportal_monitor_heap != serverConfig.liveportal_monitor_heap)
            {
                if (fieldsAsObject.liveportal_monitor_heap == "on")
                    serverConfig.liveportal_monitor_heap = "on"
                else
                    serverConfig.liveportal_monitor_heap = "off"
                if (serverConfig.liveportal_monitor_heap == "on")
                {
                    sr_api.sendMessage(DataCenterSocket,
                        sr_api.ServerPacket(
                            "MonitorHeap",
                            serverConfig.extensionname,
                            1
                        ));
                }
                else
                {
                    serverConfig.liveportal_monitor_heap = "off"
                    sr_api.sendMessage(DataCenterSocket,
                        sr_api.ServerPacket(
                            "MonitorHeap",
                            serverConfig.extensionname,
                            0
                        ));
                }
            }
            if (fieldsAsObject.logginglevel != serverConfig.logginglevel)
            {
                // change server logging level
                changeServerLogging(fieldsAsObject.logginglevel);
                serverConfig.logginglevel = fieldsAsObject.logginglevel;
            }
            // loop though our keys and set them to match what is in the modal
            for (const [key, value] of Object.entries(serverConfig))
            {
                //lets check our settings and send out updates as required
                if (key === "modmessage_channel")
                {
                    // udpate the server (or just refresh the value even if the same)
                    serverConfig[key] = fieldsAsObject[key];
                    changeDiscordListeningChannel(serverConfig[key]);
                }
                else if (key === "randomfactstimeout")
                    serverConfig[key] = fieldsAsObject[key] * 60000
                else if (value === "on" && !fieldsAsObject[key])
                    serverConfig[key] = "off";
                else if (key in fieldsAsObject)
                    serverConfig[key] = fieldsAsObject[key];
            }
        }
        //save the data to the server
        SaveConfigToServer();
    }
    // ============================================================================
    //                           FUNCTION: changeServerLogging
    // ============================================================================
    function changeServerLogging (logsetting)
    {
        sr_api.sendMessage(DataCenterSocket,
            sr_api.ServerPacket(
                "SetLoggingLevel",
                serverConfig.extensionname,
                logsetting,
            ));
    }
    // ============================================================================
    //                           FUNCTION: displayChatMessages
    // ============================================================================
    // display buffers on screen
    function displayChatMessages ()
    {
        let chatcardref = document.getElementById("ChatMessagesCardText")
        let modcardref = document.getElementById("ModMessagesCardText")

        // limit chat buffer to the number of lines we want to use
        while (localConfig.chatMessageBuffer.length > serverConfig.chatmessagebuffermaxsize)
            localConfig.chatMessageBuffer.shift();

        // limit chat buffer to the number of lines we want to use
        while (localConfig.modMessageBuffer.length > serverConfig.modmessagebuffermaxsize)
            localConfig.modMessageBuffer.shift();

        // add the buffer into the chat window
        chatcardref.innerHTML = localConfig.chatMessageBuffer.join(" ");
        modcardref.innerHTML = localConfig.modMessageBuffer.join(" ");

        // Auto scroll the boxes unless we have a new buffer, then we scroll to the end
        if (!localConfig.newTwitchChatBuffer)
            MessageboxAutoscroll("ChatMessagesCardText")
        else
        {
            const cardref = document.getElementById("ChatMessagesCardText")
            const cardScrollHeight = cardref.scrollHeight;
            cardref.scrollTo(0, cardScrollHeight + 5);
            localConfig.newTwitchChatBuffer = false;
        }

        if (!localConfig.newDiscordChatBuffer)
            MessageboxAutoscroll("ModMessagesCardText")
        else
        {
            const cardref = document.getElementById("ModMessagesCardText")
            const cardScrollHeight = cardref.scrollHeight;
            cardref.scrollTo(0, cardScrollHeight + 5);
            localConfig.newDiscordChatBuffer = false;
        }

    }
    // ============================================================================
    //                           FUNCTION: processTwitchChatBuffer
    // ============================================================================
    // Description: Processes a message from the data center with the previous chat buffer
    // Parameters: none
    // ----------------------------- notes ----------------------------------------
    // none
    // ===========================================================================
    async function processTwitchChatBuffer (chatdata)
    {
        let counter = 0
        // as we have received a bufer lets delete the old data
        document.getElementById("ChatMessagesCardText").innerHTML = "";

        localConfig.chatMessageBuffer = [];
        chatdata.forEach(ele => 
        {
            parseTwitchChatMessage(ele);
        })
        localConfig.chatMessageBuffer.push("<BR>--------- buffer loaded --------");

    }
    // ============================================================================
    //                           FUNCTION: processTwitchAccountNames
    // ============================================================================
    async function processTwitchAccountNames (extension_packet)
    {
        // as we have received a bufer lets delete the old data
        let newchatternames = ""
        let twitchnamedropdowns = ""
        let optioncode = ""
        let selectedname = false;
        let newChatAsUsername = ""
        localConfig.usernamelist = extension_packet.data;
        // if we have a username set in our config and that is in the current list of names lets use that one
        let ele = document.getElementById("ChatMessageDropdown");
        ele.innerHTML = ""
        for (const [profile_id, value] of Object.entries(extension_packet.data))
        {
            if (serverConfig.chatAsUsername && serverConfig.chatAsUsername == value
                ||serverConfig.chatAsUsername && serverConfig.chatAsUsername == profile_id
            )
            {
                selectedname = true;
                optioncode += "<option value='" + profile_id + "' selected>" + value + "</option>"
            }
            //hide the current profile on the modal box
            else
            {
                newChatAsUsername = value;
                optioncode += "<option value='" + profile_id + "'>" + value + "</option>"
            }
        }
        // if our current selection isn't in the list then set it to the first one received if any
        if (!selectedname && newChatAsUsername != "")
            serverConfig.chatAsUsername=        newChatAsUsername
        ele.innerHTML = optioncode
    }
    // ============================================================================
    //                           FUNCTION: updateChatPlatforms
    // ============================================================================
    function updateChatPlatforms ()
    {
        let twitchnamedropdowns = ""
        let value = "none"
        let ele = document.getElementById("ChatPlatformMessageDropdown");
        let firstitem = true;
        let optioncode = "";
        ele.innerHTML = "Connecting ..."
        if (localConfig.twitchplatformavailable)
        {
            if (firstitem)
            {
                firstitem = false
                optioncode += "<option value='twitch_platform_select' selected>Twitch</option>"
            }
            else
                optioncode += "<option value='twitch_platform_select'>Twitch</option>"
        }
        if (localConfig.youtubeplatformavailable)
        {
            if (firstitem)
            {
                firstitem = false
                optioncode += "<option value='youtube_platform_select' selected>YouTube</option>"
            }
            else
                optioncode += "<option value='youtube_platform_select'>YouTube</option>"
        }
        if (localConfig.twitchplatformavailable && localConfig.youtubeplatformavailable)
        {
            if (firstitem)
            {
                firstitem = false
                optioncode += "<option value='youtubetwitch_platform_select' selected>YouTube and Twitch</option>"
            }
            else
                optioncode += "<option value='youtubetwitch_platform_select'>YouTube and Twitch</option>"
        }
        ele.innerHTML = optioncode
    }
    // ============================================================================
    //                           FUNCTION: userDropdownChanged
    // ============================================================================
    function userDropdownChanged (e)
    {
        // if we have changed users update the config to remember it
        if (serverConfig.chatAsUsername != localConfig.usernamelist[e.value])
        {
            document.getElementById("ChatMessageDropdown").value = e.value
            serverConfig.chatAsUsername = localConfig.usernamelist[e.value];
            SaveConfigToServer()
        }
    }
    // ============================================================================
    //                           FUNCTION: LoadVoices
    // ===========================================================================
    function LoadVoices ()
    {
        //update TTS voices if we don't have any yet
        if (!localConfig.TTSVoiceList.length)
            localConfig.TTSVoiceList = window.speechSynthesis.getVoices();

        //filter out stuff the user is interested in
        if (serverConfig.TTSVoiceFilter != "")
        {
            localConfig.TTSVoiceList = localConfig.TTSVoiceList.filter(function (el)
            {
                return el.name.indexOf(serverConfig.TTSVoiceFilter) > -1;
            });
        }
        //sort voice list alphabetically
        function compare (a, b) { if (a.name < b.name) { return -1; } if (a.name > b.name) { return 1; } return 0; }
        localConfig.TTSVoiceList.sort(compare);
        //if we got voices then update out settings
        if (localConfig.TTSVoiceList.length)
        {
            UpdateOwnSettingsWidgetSmallData()
        }
        else
        {
            setTimeout(() =>
            {
                LoadVoices()
            }, 1000);
        }
    }
    // ============================================================================
    //                           FUNCTION: twitchVoiceDropdownChanged
    // ============================================================================
    function twitchVoiceDropdownChanged (e)
    {
        if (serverConfig.twitchTTSVoiceIndex != e.value)
        {
            document.getElementById("twitchTTSVoiceSelectionDropdown_SettingsSmallFormItem").value = e.value
            serverConfig.twitchTTSVoiceName = localConfig.TTSVoiceList[e.value].name
            serverConfig.twitchTTSVoiceIndex = e.value;
            SaveConfigToServer()
        }
    }
    // ============================================================================
    //                           FUNCTION: youtubeVoiceDropdownChanged
    // ============================================================================
    function youtubeVoiceDropdownChanged (e)
    {
        if (serverConfig.YouTubeTTSVoiceIndex != e.value)
        {
            document.getElementById("youtubeTTSVoiceSelectionDropdown_SettingsSmallFormItem").value = e.value
            serverConfig.YouTubeTTSVoiceName = localConfig.TTSVoiceList[e.value].name
            serverConfig.YouTubeTTSVoiceIndex = e.value;
            SaveConfigToServer()
        }
    }
    // ============================================================================
    //                           FUNCTION: TTSTestVoice
    // ============================================================================
    function liveportalTestVoice ()
    {
        // test voice from liveportal settings widget
        // if we have voice disabled we still want to be able to speak
        event.preventDefault();
        //document.getElementById("TestVoiceTTSVoiceSelectionDropdown").value = e.value
        let text = document.getElementById("TTSTestVoice_SettingsSmallFormItem").value;
        let voiceIndex = document.getElementById("TestVoiceTTSVoiceSelectionDropdown_SettingsSmallFormItem").value;
        TTSSpeak(voiceIndex, text)
    }
    // ============================================================================
    //                           FUNCTION: TTSSpeak
    // ============================================================================
    function TTSSpeak (voiceIndex, text, volume = 1)
    {
        let voiceId = voiceIndex;
        let message = text
        // if no voice selected just go with the first
        if (voiceIndex == undefined || voiceIndex < 0)
            voiceId = 0;
        if (!localConfig.TTSVoiceList.length)
            LoadVoices()
        if ('speechSynthesis' in window && localConfig.TTSVoiceList.length > 0)
        {
            const utterance = new SpeechSynthesisUtterance(message);
            utterance.voice = localConfig.TTSVoiceList[voiceId];
            utterance.lang = localConfig.TTSVoiceList[voiceId].lang;
            utterance.volume = volume;
            window.speechSynthesis.speak(utterance);
        } else
        {
            console.log("Your browser does not support Text-to-Speech.");
        }
    }
    // ============================================================================
    //                           FUNCTION: platformDropdownChanged
    // ============================================================================
    function platformDropdownChanged (e)
    {
        let iconsize = "style='width: 20px';"
        if (e.innerHTML == "twitch")
        {
            document.getElementById("chatplatformselect").innerHTML = "<img src='/liveportal/images/twitch_icon.png' " + iconsize + ">";
            document.getElementById("ChatPlatformMessageDropdown").setAttribute('data-value', 'twitch');
        }
        else if (e.innerHTML == "youtube")
        {
            document.getElementById("chatplatformselect").innerHTML = "<img src='/liveportal/images/youtube_icon.png' " + iconsize + ">";
            document.getElementById("ChatPlatformMessageDropdown").setAttribute('data-value', 'youtube');
        }
        else if (e.innerHTML == "youtube and twitch")
        {
            document.getElementById("chatplatformselect").innerHTML = "<img src='/liveportal/images/twitch_icon.png' " + iconsize + "><img src='/liveportal/images/youtube_icon.png' " + iconsize + ">";
            document.getElementById("ChatPlatformMessageDropdown").setAttribute('data-value', 'youtubetwitch');
        }
    }
    // ============================================================================
    //                           FUNCTION: processDiscordChatBuffer
    // ============================================================================
    // Description: Processes a message from the data center with the previous chat buffer
    // Parameters: none
    // ----------------------------- notes ----------------------------------------
    // none
    // ===========================================================================
    async function processDiscordChatBuffer (chatdata)
    {
        let counter = 0
        // as we have received a bufer lets delete the old data
        document.getElementById("ModMessagesCardText").innerHTML = "";
        localConfig.modMessageBuffer = [];

        if (chatdata)
            chatdata.forEach(ele => 
            {
                parseDiscordChatMessage(ele);
            })
        localConfig.modMessageBuffer.push("<BR>--------- buffer loaded --------");
    }
    // ============================================================================
    //                           FUNCTION: parseTwitchChatMessage
    // ============================================================================
    function parseTwitchChatMessage (chatdata)
    {
        // chat message data structure fields that are currently used/requried
        // if data = ? then it is optional
        /*
        chatdata.data["display-name"]
        chatdata = 
        {
            dateStamp = ?
            message = ...
            channel = ...
            data = 
            {
                username = ...
                "display-name" = ...
                "message-type" = ...
                mod = ?
                color = ?
                "system-msg" = ?
                "message-id" = ?
                "msg-param-category" = ?
                "custom-reward-id" = ?
                emotes = ?
                
            }
        }
        
        */

        try
        {
            //console.log("received chatdata.data['message-type']", chatdata.data["message-type"], chatdata.message)
            // Message we have currently handled, use this to develope handling of new messages yet to be seen
            // hard to test all messages as we can't generate them
            var messages_handled = ["chat", "action", "resub", "primepaidupgrade", "submysterygift", "join", "connecting", "logon", "connected", "twitchchat_extension", "disconnected", "reconnect", "sub", "resub", "messagedeleted", "timeout", "ban", "System", "raided", "notice", "usernotice", "viewermilestone", "redeem"]
            var sub_messages = ["sub", "resub", "primepaidupgrade", "submysterygift"];
            var modactions = ["messagedeleted", "timeout", "ban", "notice"]

            if (!messages_handled.includes(chatdata.data["message-type"]) && chatdata.data["display-name"] != "System" && chatdata.data["display-name"].indexOf("(localpost)") == -1)
                console.log("parseTwitchChatMessage() not handling these messages yet, still work in progress", chatdata.data)

            // setup the time fields
            var today = new Date();
            let datestamp = null
            let time = null
            // check if we have a timestamp on the chat message
            if (chatdata.dateStamp)
            {
                datestamp = new Date(chatdata.dateStamp)
                // check if we are on a new day (adds date if it was a previous days message)
                if (
                    datestamp.getDate() + ":" + String(datestamp.getMonth() + 1).padStart(2, '0') + ":" + String(datestamp.getFullYear()).padStart(2, '0')
                    !=
                    today.getDate() + ":" + String(today.getMonth() + 1).padStart(2, '0') + ":" + String(today.getFullYear()).padStart(2, '0'))
                {
                    // use DATE+Time as the message is not from today
                    time = datestamp.getDate() + ":" + String(datestamp.getMonth() + 1).padStart(2, '0') + ":" + String(datestamp.getFullYear()).padStart(2, '0') + "_" + datestamp.getHours() + ":" + String(datestamp.getMinutes()).padStart(2, '0') + ":" + String(datestamp.getSeconds()).padStart(2, '0')
                }
                else
                {
                    // set timestamp to just time if it is today.
                    time = datestamp.getHours() + ":" + String(datestamp.getMinutes()).padStart(2, '0') + ":" + String(datestamp.getSeconds()).padStart(2, '0');
                }
            }
            else
            {
                time = "--:--:--"
            }
            // make setup our fields for parts of the message
            var time_color = "<span style='color: " + chatcolors.default_timecode_color + "'>";
            var end_time_color = "</span>"
            var user_color = "";
            var end_user_color = "";
            var background_color = "";
            var end_background_color = "";
            var user_icons = "";
            var action = "";
            var endaction = "";
            //chatdata.data.username
            var banicon = "<img onclick='banUserClicked(\"" + chatdata.data.username + "\")' style='width: 20px; cursor:pointer;' alt='BanUser' title='BanUser' src = '/liveportal/images/banhammer.png'>"
            let icons = "";
            if (localConfig.bannedUsersList.includes(chatdata.data.username))
                banicon = "< img  onclick = 'unBanUserClicked(\"" + chatdata.data.username + "\")' style = 'width:20px; cursor:pointer;' alt='UnBanUser' title='UnBanUser' src='/liveportal/images/unbanhammer.png'>"


            icons = banicon + "<img style='width: 20px;' alt='Twitch' title='Twitch' src='/liveportal/images/twitch_icon.png'>"

            var mod_badge = "<img src='liveportal/images/badge_mod.png'>";
            var greyout_line = "false";

            // three main parts of a message are built up into these tags
            // linefield + time_field + name_field + message_field + endline_field
            var time_field = time_color + time + ":" + end_time_color;
            var name_field = "";
            var message_field = "";
            var line_field = "<BR><span>";
            var end_line_field = "</span>";

            // lets sanitise the message before we add the emotes
            // we do this by pushing it into an html div and then pulling it out again
            // kind of a hack but it works :D
            var sanitiser = document.createElement('div');
            sanitiser.innerText = chatdata.message
            var message = sanitiser.innerHTML
            // set the window title (might have updated)
            localConfig.twitchchatchannel = chatdata.channel
            document.getElementById("ChatMessagesCardTitle").innerHTML = "Chat: " + localConfig.twitchchatchannel + ":" + localConfig.youtubechatchannel

            //  #################################
            //   check for an action messge '/me'
            //  ################################
            if (chatdata.data["message-type"] == "action")
            {
                action = "<i>";
                endaction = "</i>"
            }
            //  ################################################################################
            //       UNHANDLED MESSAGES. NEED TO BE FORMATTED CORRECTLY
            //  ################################################################################
            if (!(messages_handled.includes(chatdata.data["message-type"])))
            {
                background_color = "<span style='color:" + chatcolors.default_TBD_text_color + "; background-color: " + chatcolors.default_TBD_background_color + "; '>";
                message = message + " <message-type>: " + ((chatdata.data["message-type"]) ? chatdata.data["message-type"] : "")
                end_background_color = "</span>"
            }

            //  ##################################
            //  check if someone @'d us
            //  ##################################
            if (localConfig.usernamelist && localConfig.usernamelist.user && chatdata.message && chatdata.message.toLowerCase().indexOf('@' + localConfig.usernamelist.user.toLowerCase()) > -1)
            {
                var myregex = new RegExp("@" + localConfig.usernamelist.user, "gi")
                message = message.replace(myregex, "<span style='color:" + chatcolors.default_text_bright_color + ";background-color: " + chatcolors.default_user_at_color + ";'> @" + localConfig.usernamelist.user + "</span>")
            }

            //  ##################################
            //      add any twitch emotes
            //  ##################################
            message = addTwitchEmotes(message, chatdata.data.emotes);
            //  ##################################
            //      add BTTV emotes
            //  ##################################
            message = addBTTVEmotes(message);

            //  ##################################
            //     Mod Actions
            //  ##################################
            if ((modactions.includes(chatdata.data["message-type"])))
            {
                icons = icons + mod_badge;
                line_field = "<BR><span style='color: " + chatcolors.default_mod_action + "'>"
                name_field = chatdata.data['display-name'] + "> ";
                message_field = message;
                // set the card data
                localConfig.chatMessageBuffer.push(line_field + time_field + icons + name_field + message_field + end_line_field);
            }
            // ########################################## 
            //  Our Bot messages (ie chatbot)
            // ##########################################
            else if (localConfig.usernamelist && chatdata.data['display-name'] === localConfig.usernamelist.bot && chatdata.data["message-type"] == "chat")
            {
                icons = icons + mod_badge;
                line_field = "<BR><span style='color: " + chatcolors.default_greyout_color + "'>"
                name_field = chatdata.data['display-name'] + "> ";
                message_field = message;
                // set the card data
                localConfig.chatMessageBuffer.push(line_field + time_field + icons + name_field + message_field + end_line_field);
            }

            // ##################### 
            //  system messages 
            // #####################
            else if (chatdata.data['display-name'] === "System")
            {
                // set the card data
                line_field = "<BR><span style='color: " + chatcolors.default_system_color + "'>"
                name_field = chatdata.data['display-name'] + "> ";
                message_field = message;
                localConfig.chatMessageBuffer.push(line_field + time_field + icons + name_field + message_field + end_line_field);
                //localConfig.chatMessageBuffer.push("<BR><span style='color: " + default_system_color + "'>" + time + "::: " + chatdata.data['display-name'] + " " + message + "</span>");
            }
            // ##################### 
            //     sub messages 
            // #####################
            else if (sub_messages.includes(chatdata.data["message-type"]))
            {
                line_field = "<BR><span style='color: " + chatcolors.default_sub_color + "'>"
                name_field = "<b>" + chatdata.data['display-name'] + "> ";
                message_field = chatdata.data['system-msg'] + ((message) ? ": " + message : "") + "</b>";
                localConfig.chatMessageBuffer.push(line_field + time_field + icons + name_field + message_field + end_line_field);
            }
            // ##################### 
            //   chat messages 
            // #####################
            else
            {
                // ######################### reward messages #########################
                if (chatdata.data["msg-id"] || chatdata.data["custom-reward-id"])
                {
                    if (chatdata.data["msg-id"] == "vierwermilestone")
                    {
                        background_color = " <b><span style='color: " + chatcolors.default_reward_color + "; background-color: " + chatcolors.default_reward_bgcolor + "; '>";
                        end_background_color = "</span></b>"
                    }
                    else
                    {
                        background_color = ((chatdata.data["msg-id"]) ? chatdata.data["msg-id"] : "CustomReward:") + " <b><span style='color: " + chatcolors.default_reward_color + "; background-color: " + chatcolors.default_reward_bgcolor + "; '>";
                        end_background_color = "</span></b>"
                    }
                }
                // ##################### username colors and icons
                // if this is not a chat message (ie a sub etc) then set username color to yellow
                if (chatdata.data["message-type"] != "chat" && chatdata.data["message-type"] != "action")
                    user_color = "<span style='color: yellow'>";
                // if the user is a mod then add the mod badge
                else if (chatdata.data.mod)
                {
                    icons = icons + mod_badge;
                    user_color = "<span style='color:" + chatdata.data.color + "'>";
                }
                // if we don't have a user color then lets use that instead
                else if (chatdata.data.color === null)
                    user_color = "<span style='color: " + chatcolors.default_username_color + "'>";
                // use standard color if no coler is available
                else
                    user_color = "<span style='color: " + chatdata.data.color + "'>";

                name_field = user_color + chatdata.data['display-name'] + "&gt</span> ";

                // ########### create our message line
                // set the card title (may have changed since last time around)

                // if we have a nonchat or action message highlight it so we know we need to fix this
                if (chatdata.data["message-type"] == "chat" && chatdata.data["message-type"] == "action")
                    message_field = background_color + action + message + endaction + end_background_color
                else if (chatdata.data["message-type"] == "viewermilestone")
                    message_field = background_color + action + chatdata.data["msg-param-category"] + ": " +
                        chatdata.data["system-msg"] + ": " + message + endaction + end_background_color
                else // unhandled message
                    message_field = background_color + action + message + endaction + end_background_color

                localConfig.chatMessageBuffer.push(line_field + time_field + icons + name_field + message_field + "<" + chatdata.data["message-type"] + ">" + end_line_field);

                // add mod messages to mod card if we have this option selected in the liveportal settings page
                if (serverConfig.modchattomodwindow === "on" && chatdata.data.mod)
                    //localConfig.modMessageBuffer.push("<BR>" + time + username + " " + message);
                    localConfig.modMessageBuffer.push(line_field + time_field + name_field + message_field + "<" + chatdata.data["message-type"] + ">" + end_line_field);

            }
        }
        catch (error)
        {
            console.log("ERROR:parseTwitchChatMessage:", error)
        }
    }

    // ============================================================================
    //                           FUNCTION: parseYoutubeChatMessage
    // ============================================================================
    function parseYoutubeChatMessage (chatdata)
    {
        try
        {
            var today = new Date();
            let datestamp = new Date(today)
            let icons = "<img style='width: 20px;' alt='Youtube' title='Youtube' src='/liveportal/images/youtube_icon.png'>"

            let time = datestamp.getHours() + ":" + String(datestamp.getMinutes()).padStart(2, '0') + ":" + String(datestamp.getSeconds()).padStart(2, '0');

            // make setup our fields for parts of the message
            var time_color = "<span style='color: " + chatcolors.default_timecode_color + "'>";
            var end_time_color = "</span>"
            var user_color = "";
            var end_user_color = "";
            var background_color = "";
            var end_background_color = "";
            var user_icons = "";
            var action = "";
            var endaction = "";
            var mod_badge = "<img src='liveportal/images/badge_mod.png'>";
            var greyout_line = "false";

            // three main parts of a message are built up into these tags
            // linefield + time_field + name_field + message_field + endline_field
            var time_field = time_color + time + ":" + end_time_color;
            var name_field = "";
            var message_field = "";
            var line_field = "<BR><span>";
            var end_line_field = "</span>";

            // lets sanitise the message before we add the emotes
            // we do this by pushing it into an html div and then pulling it out again
            // kind of a hack but it works :D
            var sanitiser = document.createElement('div');
            sanitiser.innerText = chatdata.message
            var message = sanitiser.innerHTML
            // set the window title (might have updated)
            localConfig.youtubechatchannel = chatdata.channel
            document.getElementById("ChatMessagesCardTitle").innerHTML = "Chat: " + localConfig.twitchchatchannel + ":" + localConfig.youtubechatchannel

            //  ##################################
            //  check if someone @'d us
            //  ##################################
            if (localConfig.usernamelist && localConfig.usernamelist.user && chatdata.message && chatdata.message.toLowerCase().indexOf('@' + localConfig.usernamelist.user.toLowerCase()) > -1)
            {
                var myregex = new RegExp("@" + localConfig.usernamelist.user, "gi")
                message = message.replace(myregex, "<span style='color:" + chatcolors.default_text_bright_color + ";background-color: " + chatcolors.default_user_at_color + ";'> @" + localConfig.usernamelist.user + "</span>")
            }

            //  ##################################
            //      add BTTV emotes
            //  ##################################
            message = addBTTVEmotes(message);
            // ########################################## 
            //  Our Bot messages (ie chatbot)
            // ##########################################
            if (localConfig.usernamelist && chatdata.sender === localConfig.usernamelist.bot)
            {
                icons = icons + mod_badge;
                line_field = "<BR><span style='color: " + chatcolors.default_greyout_color + "'>"
                name_field = chatdata.sender + "> ";
                message_field = message;
                // set the card data
                localConfig.chatMessageBuffer.push(line_field + time_field + icons + name_field + message_field + end_line_field);
            }

            // ##################### username colors and icons
            // if this is not a chat message (ie a sub etc) then set username color to yellow
            if (chatdata.color === null)
                user_color = "<span style='color: " + chatcolors.default_username_color + "'>";
            // use standard color if no coler is available
            else
                user_color = "<span style='color: " + chatdata.color + "'>";

            name_field = user_color + chatdata.sender + "&gt</span> ";

            // ########### create out message line
            message_field = background_color + message + end_background_color

            localConfig.chatMessageBuffer.push(line_field + time_field + icons + name_field + message_field + "<youtubechat>" + end_line_field);

        }
        catch (error)
        {
            console.log("ERROR:parseYoutubeChatMessage:", error)
        }
    }
    // ============================================================================
    //                           FUNCTION: parseTwitchRedemption
    //     add a twitch redemption message to chat window
    // ============================================================================
    function parseTwitchRedemption (chatdata)
    {
        try
        {
            // setup the date field
            var today = new Date();
            var time = today.getHours() + ":" + String(today.getMinutes()).padStart(2, '0') + ":" + String(today.getSeconds()).padStart(2, '0');
            // make setup our fields for parts of the message
            var time_color = "<span style='color: " + chatcolors.default_timecode_color + "'>";
            var end_time_color = "</span>"
            var user_color = "";
            var end_user_color = "";
            var background_color = "";
            var end_background_color = "";
            var user_icons = "";
            var mod_badge = "<img src='liveportal/images/badge_mod.png'>";

            // three main parts of a message are built up into these tags
            // linefield + time_field + name_field + message_field + endline_field
            var time_field = time_color + time + ":" + end_time_color;
            var name_field = "";
            var message_field = "";
            var line_field = "<BR><span>";
            var end_line_field = "</span>";

            // lets sanitise the message before we add the emotes
            // we do this by pushing it into an html div and then pulling it out again
            // kind of a hack but it works :D
            var sanitiser = document.createElement('div');
            sanitiser.innerText = chatdata.parameters.message
            var message = sanitiser.innerHTML

            // ##################### 
            //  Format as system message 
            // #####################

            // set the card data
            line_field = "<BR><span style='color: " + chatcolors.default_system_color + "'>"
            name_field = chatdata.parameters.user + "> ";

            background_color = "<b><span style='color: " + chatcolors.default_reward_color + "; background-color: " + chatcolors.default_reward_bgcolor + "; '>";
            end_background_color = "</span></b>"

            message_field = background_color + "Redeemed: " + chatdata.parameters.title + message + end_background_color
            localConfig.chatMessageBuffer.push(line_field + time_field + name_field + message_field + end_line_field);

        }
        catch (error)
        {
            console.log("ERROR:parseTwitchRedemption:", error)
        }
    }
    // ============================================================================
    //                           FUNCTION: parseDiscordChatMessage
    // ============================================================================
    // updates the buffer with the messages
    function parseDiscordChatMessage (chatdata)
    {
        //let chatdata = data.data;
        let today = new Date();
        let time = today.getHours() + ":" + String(today.getMinutes()).padStart(2, '0') + ":" + String(today.getSeconds()).padStart(2, '0');
        // make it colorful
        let time_color = "<span style='color: #757875'>";
        var end_time_color = "</span>";
        let user_color = "";
        // https://cdn.discordapp.com/emojis/634006521180717067
        let message = parseDiscordEmojis(chatdata.message);
        // lets sanitise the message before we add the emotes
        var sanitiser = document.createElement('div');
        if (chatdata.name === "System")
            localConfig.modMessageBuffer.push("<BR><span style='color: red'>" + time + ":" + chatdata.name + " " + message + "</span>");
        else
        {
            user_color = "<span style='color: #6f42c1'>";
            let username = user_color + ' ' + chatdata.name + "&gt</span>";
            time = time_color + time + ":" + end_time_color;

            localConfig.modMessageBuffer.push("<BR>" + time + ":" + username + " " + message);

        }
    }
    // ============================================================================
    //                           FUNCTION: addDiscordEmotes

    // ============================================================================
    function parseDiscordEmojis (message)
    {
        let index = message.indexOf('<');
        let is, ie, emoji = 0;
        let msg = message;
        let newmessage = ""
        if (msg.indexOf('<') == -1)
            return message;

        // check if we have emoji. this should really be a bit better, ie a patternmatch (in the form of <name:id>)
        while (msg.indexOf('<') > 0)
        {
            //log the start of the possible emoji
            index = msg.indexOf('<');
            // get the start of the id
            is = msg.indexOf(':', index + 2);
            // get the end of the id string
            ie = msg.indexOf('>', index)
            // get the first part of the message (up to the next emoji)
            newmessage = newmessage + msg.slice(0, index);
            // get the emoji
            emoji = msg.slice(is + 1, ie);
            // remove the message up to the emoji
            msg = msg.slice(ie + 1); // skip past the first '<:'
            // add the emoji to the message
            newmessage = newmessage + "<img src='https://cdn.discordapp.com/emojis/" + emoji + "' width='25' height='25'>";
        }
        return newmessage;
    }
    // ============================================================================
    //                           FUNCTION: addTwitchEmotes
    // ============================================================================
    function addTwitchEmotes (message, emotes)
    {
        if (!emotes) return message;

        // store all emote keywords
        // ! you have to first scan through 
        // the message string and replace later
        const stringReplacements = [];
        let theme = "light"
        if (localStorage.getItem("darkmode") === "true")
            theme = "dark"
        // iterate of emotes to access ids and positions
        Object.entries(emotes).forEach(([id, positions]) =>
        {
            // use only the first position to find out the emote key word
            const position = positions[0];
            const [start, end] = position.split("-");
            const stringToReplace = message.substring(
                parseInt(start, 10),
                parseInt(end, 10) + 1
            );
            if (stringToReplace != ":/")
                stringReplacements.push({
                    stringToReplace: stringToReplace,
                    //replacement: "< img src = "https://static-cdn.jtvnw.net/emoticons/v1/" + id + "/1.0" > ",
                    replacement: "<img src='https://static-cdn.jtvnw.net/emoticons/v2/" + id + "/default/" + theme + "/1.0'>"
                });
        });

        // generate HTML and replace all emote keywords with image elements
        const messageHTML = stringReplacements.reduce(
            (acc, { stringToReplace, replacement }) =>
            {
                // obs browser doesn't srsmm to know about replaceAll
                return acc.split(stringToReplace).join(replacement);
            },
            message
        );
        return messageHTML.replaceAll("\n", "<BR>");;
    }
    // ============================================================================
    //                           FUNCTION: addBTTVEmotes
    // ============================================================================
    function addBTTVEmotes (message)
    {
        for (var key of Object.keys(localConfig.bTTVEmotes))
        {
            if (message == localConfig.bTTVEmotes[key].code
                || message.includes(" " + localConfig.bTTVEmotes[key].code + " ")
                || (message.indexOf(localConfig.bTTVEmotes[key].code + " ")) == 0
                || message.endsWith(" " + localConfig.bTTVEmotes[key].code)
            )
            {
                message = message.replaceAll(localConfig.bTTVEmotes[key].code, "<img src='https://cdn.betterttv.net/emote/" + localConfig.bTTVEmotes[key].id + "/1x.webp'>")
            }
        }
        return message
    }
    // ============================================================================
    //                           FUNCTION:DisplayAlertMessages
    // ============================================================================
    // Description: display alerts
    // Parameters: alert message
    // ----------------------------- notes ----------------------------------------
    // None
    // ===========================================================================
    function DisplayAlertMessages (message)
    {
        let cardref = document.getElementById("AlertCardText");
        cardref.innerHTML = cardref.innerHTML + message
        // keep scroll at the bottom of the card
        var cardScrollHeight = cardref.scrollHeight;
        cardref.scrollTo(0, cardScrollHeight + 1);
    }

    // ============================================================================
    //                           FUNCTION:MessageboxAutoscroll
    // ============================================================================
    // Description: keeps a message box scrolled if user hasn't scrolled up
    // Parameters: e
    // ----------------------------- notes ----------------------------------------
    // None
    // ===========================================================================
    function MessageboxAutoscroll (messageBoxName)
    {
        let container = document.getElementById(messageBoxName)
        // only scroll if the mouse isn't down (user srolling) or if we are already 
        // within 100 pixels of the new mesages coming in. 
        if (!localConfig.mouseDown && ((container.scrollHeight - (container.scrollTop + container.clientHeight)) < 100))
            container.scrollTop = container.scrollHeight + 1;

    }
    // ============================================================================
    //                           FUNCTION: RequestExtList
    // ============================================================================
    // Description: Sends a message to the data center to get the list of extensions
    // Parameters: none
    // ----------------------------- notes ----------------------------------------
    // none
    // ===========================================================================
    function RequestExtList ()
    {
        sr_api.sendMessage(DataCenterSocket,
            sr_api.ServerPacket(
                "RequestExtensionsList",
                serverConfig.extensionname,
            ));
        RequestChList();
    }
    // ============================================================================
    //                           FUNCTION: RequestOBSScenes
    // ============================================================================
    // Description: Sends a message to the data center to get the list of extensions
    // Parameters: none
    // ----------------------------- notes ----------------------------------------
    // none
    // ===========================================================================
    function RequestOBSScenes (to)
    {
        sr_api.sendMessage(DataCenterSocket,
            sr_api.ServerPacket(
                "ExtensionMessage",
                serverConfig.extensionname,
                sr_api.ExtensionPacket(
                    "RequestScenes",
                    serverConfig.extensionname,
                ),
                "",
                to,
            ));
    }
    // ============================================================================
    //                           FUNCTION: RequestChList
    // ============================================================================
    // Description: Sends a message to the data center to get the list of channels
    // Parameters: none
    // ----------------------------- notes ----------------------------------------
    // none
    // ===========================================================================
    function RequestChList ()
    {
        sr_api.sendMessage(DataCenterSocket,
            sr_api.ServerPacket(
                "RequestChannelsList",
                serverConfig.extensionname,
            ));
    }
    // ============================================================================
    //                           FUNCTION: RequestChatBuffer
    // ============================================================================
    // Description: Sends a message to the data center to get the previous chat buffer
    // Parameters: none
    // ----------------------------- notes ----------------------------------------
    // none
    // ===========================================================================
    function RequestChatBuffer (extname)
    {
        sr_api.sendMessage(DataCenterSocket,
            sr_api.ServerPacket("ExtensionMessage",
                serverConfig.extensionname,
                sr_api.ExtensionPacket(
                    "RequestChatBuffer",
                    serverConfig.extensionname,
                    "",
                    "",
                    extname),
                "",
                extname
            ));
    }
    // ============================================================================
    //                           FUNCTION: RequestMacros
    // ============================================================================
    function RequestMacros ()
    {
        sr_api.sendMessage(DataCenterSocket,
            sr_api.ServerPacket("ExtensionMessage",
                serverConfig.extensionname,
                sr_api.ExtensionPacket(
                    "RequestMacros",
                    serverConfig.extensionname,
                    "",
                    "",
                    "autopilot"),
                "",
                "autopilot"
            ));
    }
    // ============================================================================
    //                           FUNCTION: RequestMacros
    // ============================================================================
    function RequestTwitchStats ()
    {
        sr_api.sendMessage(DataCenterSocket,
            sr_api.ServerPacket("ExtensionMessage",
                serverConfig.extensionname,
                sr_api.ExtensionPacket(
                    "action_GetTwitchStats",
                    serverConfig.extensionname,
                    {
                        ActionId: "liveportalRequest"
                    },
                ),
                "",
                "twitch"
            ));
    }
    // ============================================================================
    //                           FUNCTION: RequestTwitchAccountNames
    // ============================================================================
    // Description: Get our usernames from the twitch extension (so we can post as them)
    // Parameters: none
    // ----------------------------- notes ----------------------------------------
    // none
    // ===========================================================================
    function RequestTwitchAccountNames (extname)
    {
        sr_api.sendMessage(DataCenterSocket,
            sr_api.ServerPacket("ExtensionMessage",
                serverConfig.extensionname,
                sr_api.ExtensionPacket(
                    "RequestAccountNames",
                    serverConfig.extensionname,
                    "",
                    "",
                    extname),
                "",
                extname
            ));
    }
    // ============================================================================
    //                           FUNCTION: RequestSettingsWidgetSmallsCode
    // ============================================================================
    // Description: Sends a message to the extension to gets its html code
    // Parameters: none
    // ----------------------------- notes ----------------------------------------
    // none
    // ===========================================================================
    function RequestSettingsWidgetSmallsCode (extname)
    {
        sr_api.sendMessage(DataCenterSocket,
            sr_api.ServerPacket("ExtensionMessage",
                serverConfig.extensionname,
                sr_api.ExtensionPacket(
                    "RequestSettingsWidgetSmallCode",
                    serverConfig.extensionname,
                    "",
                    "",
                    extname),
                "",
                extname
            ));
    }

    // ============================================================================
    //                           FUNCTION: RequestSettingsWidgetLargeCode
    // ============================================================================
    // Description: Sends a message to the extension to gets its html code
    // Parameters: none
    // ----------------------------- notes ----------------------------------------
    // none
    // ===========================================================================
    function RequestSettingsWidgetLargeCode (extname)
    {
        sr_api.sendMessage(DataCenterSocket,
            sr_api.ServerPacket("ExtensionMessage",
                serverConfig.extensionname,
                sr_api.ExtensionPacket(
                    "RequestSettingsWidgetLargeCode",
                    serverConfig.extensionname,
                    "",
                    "",
                    extname),
                "",
                extname
            ));
    }
    // ============================================================================
    //                           FUNCTION: RequestLoggingLevel
    // ============================================================================
    function RequestLoggingLevel ()
    {
        sr_api.sendMessage(DataCenterSocket,
            sr_api.ServerPacket(
                "RequestLoggingLevel",
                serverConfig.extensionname,
            ));
    }
    // ============================================================================
    //                           FUNCTION: ProcessStreamlabsAlert
    // ============================================================================
    function ProcessStreamlabsAlert (extension_packet)
    {
        let alertdata = extension_packet.data;
        // display the alert

        let messagetxt = "Thankyou ";
        let alerttext = "";
        switch (alertdata.messagetype)
        {
            case "trigger_TwitchFollowReceived":
                messagetxt += alertdata.parameters.username + " for the follow."
                if (serverConfig.follows === "on")
                    PostMessageToDiscord(messagetxt, serverConfig.donations_channel);
                alerttext = "<div class='text-secondary'>TwitchFollow: " + alertdata.parameters.username + "</div>";
                DisplayAlertMessages(alerttext);
                break;
            case "trigger_TwitchRaidReceived":
                messagetxt += alertdata.parameters.username + " for the raid " + alertdata.parameters.raiders + " raiders."
                if (serverConfig.raids === "on")
                    PostMessageToDiscord(messagetxt, serverConfig.donations_channel);
                alerttext = "<div class='text-success'>TwitchRaid: " + alertdata.parameters.username + " " + alertdata.parameters.raiders + "</div>";
                DisplayAlertMessages(alerttext);
                //postMessageToTwitch("!so " + alertdata.parameters.username)
                //console.log("Removed streamlabs api raid message to twitch", alertdata)
                break;
            case "trigger_TwitchHostReceived":
                messagetxt += alertdata.parameters.username + " for the host with " + alertdata.parameters.viewers + " viewers."
                if (serverConfig.hosts === "on")
                    PostMessageToDiscord(messagetxt, serverConfig.donations_channel);
                alerttext = "<div class='text-success'>TwitchHost: " + alertdata.parameters.username + " " + alertdata.parameters.viewers + "</div>";
                DisplayAlertMessages(alerttext);
                break;
            case "trigger_StreamlabsDonationReceived":
                if (alertdata.parameters.message === null)
                    messagetxt += alertdata.parameters.username + " for the " + alertdata.parameters.formatted_amount + ' donation and helping keep the stream alive.'
                else
                    messagetxt += alertdata.parameters.username + " for the " + alertdata.parameters.formatted_amount + ' donation and helping keep the stream alive. "' + alertdata.parameters.message + '"'
                if (serverConfig.donations === "on")
                    PostMessageToDiscord(messagetxt, serverConfig.donations_channel);
                postMessageToTwitch(messagetxt, "user")
                alerttext = "<div class='text-danger'>SLDonation: " + alertdata.parameters.username + "  " + alertdata.parameters.formatted_amount + ' "' + alertdata.parameters.message + '"</div>';
                DisplayAlertMessages(alerttext);
                break;
            case "trigger_TwitchCharityDonationReceived":
                if (alertdata.parameters.message === null)
                    messagetxt += alertdata.parameters.username + " for the " + alertdata.parameters.formatted_amount + ' donation to charity, you are an awesome human being.'
                else
                    messagetxt += alertdata.parameters.username + " for the " + alertdata.parameters.formatted_amount + ' donation to charity, you are an awesome human being. "' + alertdata.parameters.message + '"'
                if (serverConfig.donations === "on")
                    PostMessageToDiscord(messagetxt, serverConfig.donations_channel);
                postMessageToTwitch(messagetxt, "user")
                alerttext = "<div class='text-danger'>Twitch Charity Donation: " + alertdata.parameters.username + "  " + alertdata.parameters.formatted_amount + ' "' + alertdata.parameters.message + '"</div>';
                DisplayAlertMessages(alerttext);
                break;
            case "trigger_TwitchBitsReceived":
                if (alertdata.parameters.message === null)
                    messagetxt += alertdata.parameters.username + " for the " + alertdata.parameters.amount + ' bits.'
                else
                    messagetxt += alertdata.parameters.username + " for the " + alertdata.parameters.amount + ' bits. "' + alertdata.parameters.message + '"'
                if (serverConfig.bits === "on")
                    PostMessageToDiscord(messagetxt, serverConfig.donations_channel);
                alerttext = "<div class='text-danger'>TwitchBits: " + alertdata.parameters.username + " " + alertdata.parameters.amount + ' bits. "' + alertdata.parameters.message + '"</div>';
                DisplayAlertMessages(alerttext);
                break;
            case "trigger_TwitchSubscriptionReceived":
                if (alertdata.parameters.type === "subgift" && alertdata.parameters.gifter != null)
                {
                    messagetxt += alertdata.parameters.username + " was gifted a sub from " + alertdata.parameters.gifter
                    if (serverConfig.subs === "on")
                        PostMessageToDiscord(messagetxt, serverConfig.donations_channel);
                    alerttext = "<div class='text-secondary'TwitchSubGift" + alertdata.parameters.username + '</div>';
                    DisplayAlertMessages(alerttext);
                }
                else
                {
                    let submessage = alertdata.parameters.message;
                    if (submessage === null)
                        submessage = ""
                    if (alertdata.parameters.months === 1)
                        messagetxt += alertdata.parameters.username + " for the " + alertdata.parameters.months + ' month subscription. "' + submessage + '"'
                    else
                        messagetxt += alertdata.parameters.username + " for " + alertdata.parameters.months + ' months of subscriptions. "' + submessage + '"'
                    if (serverConfig.subs === "on")
                        PostMessageToDiscord(messagetxt, serverConfig.donations_channel);
                    alerttext = "<div class='text-primary'>TwitchSubscription: " + alertdata.parameters.username + " " + alertdata.parameters.months + 'm "' + submessage + '"</div>';
                    DisplayAlertMessages(alerttext);
                }
                break;
            case "trigger_TwitchResubReceived":
                if (alertdata.parameters.message === null)
                    messagetxt += alertdata.parameters.username + " for " + alertdata.parameters.months + ' months of subcriptions (with a streak of ' + alertdata.parameters.streak_months + ').'
                else
                    messagetxt += alertdata.parameters.username + " for " + alertdata.parameters.months + ' months of subcriptions (with a streak of ' + alertdata.parameters.streak_months + '). "' + alertdata.parameters.message + '"'
                if (serverConfig.resubs === "on")
                    PostMessageToDiscord(messagetxt, serverConfig.donations_channel);
                alerttext = "<div class='text-primary'>TwitchResub: " + alertdata.parameters.username + " " + alertdata.parameters.months + 'm (' + alertdata.parameters.streak_months + ' streak). "' + alertdata.parameters.message + '"</div>';
                DisplayAlertMessages(alerttext);
                break;

            case "trigger_TwitchTwitchSubMysteryGiftReceived":
                messagetxt += alertdata.parameters.gifter + " for the " + alertdata.parameters.amount + " gifted subs"
                //postMessageToTwitch(messagetxt)
                if (serverConfig.giftsubs === "on")
                    PostMessageToDiscord(messagetxt, serverConfig.donations_channel);
                alerttext = "<div class='text-danger'>TwitchGiftSub: " + alertdata.parameters.gifter + " gifted " + alertdata.parameters.amount + " subs</div>"
                DisplayAlertMessages(alerttext);
                break;
            case "trigger_MerchPurchaseReceived"://trigger
                messagetxt += alertdata.parameters.username + " purchacing my merch. Hope you enjoy the " + alertdata.parameters.product + ". " + alertdata.parameters.imageHref
                if (serverConfig.merch === "on")
                    PostMessageToDiscord(messagetxt, serverConfig.donations_channel);
                postMessageToTwitch(messagetxt, "user")
                alerttext = "<div class='text-secondary'>SLMerch: " + alertdata.parameters.username + "  " + alertdata.parameters.product + "</div>"
                DisplayAlertMessages(alerttext);
                break;
            case "LoyaltyStoreRedemptionReceived"://trigger
                messagetxt += alertdata.parameters.username + " for using the your channel points for " + alertdata.parameters.product + ". " + alertdata.parameters.imageHref
                if (serverConfig.cloudbotredemption === "on")
                    PostMessageToDiscord(messagetxt, serverConfig.donations_channel);
                postMessageToTwitch(messagetxt, "user")
                alerttext = "<div class='text-secondary'>SLLoyalty: " + alertdata.parameters.username + " " + alertdata.parameters.product + "</div>"
                DisplayAlertMessages(alerttext);
                break;
            case "trigger_YouTubeSubscriptionReceived":
                messagetxt += alertdata.parameters.username + " for the Subscription."
                if (serverConfig.follows === "on")
                    PostMessageToDiscord(messagetxt, serverConfig.donations_channel);
                alerttext = "<div class='text-secondary'>YouTubeSubscription: " + alertdata.parameters.username + "</div>";
                DisplayAlertMessages(alerttext);
                break;
            case "trigger_YouTubeMemberReceived":
                messagetxt += alertdata.parameters.username + " for the " + alertdata.parameters.months + " Membership."
                if (serverConfig.follows === "on")
                    PostMessageToDiscord(messagetxt, serverConfig.donations_channel);
                alerttext = "<div class='text-secondary'>YouTubeMembership: " + alertdata.parameters.username + " " + alertdata.parameters.months + "months</div>";
                DisplayAlertMessages(alerttext);
                break;
            case "trigger_YouTubeSuperchatReceived":
                if (alertdata.parameters.message === null)
                    messagetxt += alertdata.parameters.username + " for the " + alertdata.parameters.formatted_amount + ' superchat, you are an awesome human being.'
                else
                    messagetxt += alertdata.parameters.username + " for the " + alertdata.parameters.formatted_amount + ' superchat, you are an awesome human being. "' + alertdata.parameters.message + '"'
                if (serverConfig.donations === "on")
                    PostMessageToDiscord(messagetxt, serverConfig.donations_channel);
                postMessageToTwitch(messagetxt, "user")
                alerttext = "<div class='text-danger'>YouTubeSuperChat: " + alertdata.parameters.username + "  " + alertdata.parameters.formatted_amount + ' "' + alertdata.parameters.message + '"</div>';
                DisplayAlertMessages(alerttext);
                break;
        }
    }
    // ============================================================================
    //                           FUNCTION: PostMessageToDiscord
    // ============================================================================
    function PostMessageToDiscord (msg, channel)
    {
        sr_api.sendMessage(DataCenterSocket,
            sr_api.ServerPacket("ExtensionMessage",
                serverConfig.extensionname,
                sr_api.ExtensionPacket(
                    "action_DiscordPostMessage",
                    serverConfig.extensionname,
                    {
                        message: msg,
                        channel: channel,
                        file: ""
                    },
                    "",
                    "discordchat"),
                "",
                "discordchat"
            ));
    }
    // ============================================================================
    //                           FUNCTION: postMessageToTwitter
    // ============================================================================
    function postMessageToTwitter (msg1, msg2)
    {

        msg1 += " ";
        msg2 += " ";
        let msg_end = "Sent from StreamRoller";
        let msg_fact = "";
        if (serverConfig.randomfactstwitterstartenabled == "on" && localConfig.randomFact !== "")
            msg_fact = "FOTD:" + localConfig.randomFact + " ";

        // we have enough space for everything 
        if (((msg1.length - 12) + msg2.length + msg_fact.length + msg_end.length) < 281)
            msg1 = msg1 + msg2 + msg_fact + msg_end;
        //we have enough space if we remove the extra message
        else if (((msg1.length - 12) + msg_fact.length + msg_end.length) < 281)
            msg1 = msg1 + msg_fact + msg_end;
        //we can't fit random fact and main message in so remove the random fact
        else if (((msg1.length - 12) + msg2.length + msg_end.length) < 281)
            msg1 = msg1 + msg2 + msg_end;
        sr_api.sendMessage(DataCenterSocket,
            sr_api.ServerPacket("ExtensionMessage",
                serverConfig.extensionname,
                sr_api.ExtensionPacket(
                    "action_PostTweet",
                    serverConfig.extensionname,
                    { message: msg1 },
                    "",
                    "twitter"),
                "",
                "twitter"
            ));
        // get a new random fact
        RequestRandomFact();
    }
    // ============================================================================
    //                           FUNCTION: postMessageToTwitch
    // ============================================================================
    function postMessageToTwitch (msg, account = "bot")
    {
        sr_api.sendMessage(DataCenterSocket,
            sr_api.ServerPacket("ExtensionMessage",
                serverConfig.extensionname,
                sr_api.ExtensionPacket(
                    "action_SendChatMessage",
                    serverConfig.extensionname,
                    // need to read accounts from twitchchat ext and give an option to chose who to send the message as
                    {
                        account: account,
                        message: msg,
                        'message-type': "chat"
                    },
                    "",
                    "twitchchat"),
                "",
                "twitchchat"
            ));
    }

    // ============================================================================
    //                           FUNCTION: postMessageToYoutube
    // ============================================================================
    function postMessageToYoutube (msg)
    {
        // work out if we are on youtube extension or youtubeAPI
        if (livePortalVolatileData.extensions.youtubeapi)

            sr_api.sendMessage(DataCenterSocket,
                sr_api.ServerPacket("ExtensionMessage",
                    serverConfig.extensionname,
                    sr_api.ExtensionPacket(
                        "action_youtubeAPIPostLiveChatMessage",
                        serverConfig.extensionname,
                        // need to read accounts from twitchchat ext and give an option to chose who to send the message as
                        {
                            message: msg,
                        },
                        "",
                        "youtubeapi"),
                    "",
                    "youtubeapi"
                ));
        else
            sr_api.sendMessage(DataCenterSocket,
                sr_api.ServerPacket("ExtensionMessage",
                    serverConfig.extensionname,
                    sr_api.ExtensionPacket(
                        "action_youtubePostLiveChatMessage",
                        serverConfig.extensionname,
                        // need to read accounts from twitchchat ext and give an option to chose who to send the message as
                        {
                            message: msg,
                        },
                        "",
                        "youtube"),
                    "",
                    "youtube"
                ));
    }
    // ============================================================================
    //                           FUNCTION: changeDiscordListeningChannel
    // ============================================================================
    function changeDiscordListeningChannel (channel)
    {
        sr_api.sendMessage(DataCenterSocket,
            sr_api.ServerPacket("ExtensionMessage",
                serverConfig.extensionname,
                sr_api.ExtensionPacket(
                    "ChangeListeningChannel",
                    serverConfig.extensionname,
                    channel,
                    "",
                    "discordchat"),
                "",
                "discordchat"
            ));
    }
    // ============================================================================
    //                           FUNCTION: chatInput
    // ============================================================================
    function chatInput (event)
    {
        let platform = document.getElementById("ChatPlatformMessageDropdown").value;
        event.preventDefault();
        if (platform.includes("twitch"))
            postMessageToTwitch(document.getElementById("chatInputText").value, serverConfig.chatAsUsername)
        if (platform.includes("youtube"))
            postMessageToYoutube(document.getElementById("chatInputText").value)

        document.getElementById("chatInputText").value = ""
    }
    // ============================================================================
    //                           FUNCTION: modInput
    // ============================================================================
    function modInput (event)
    {
        event.preventDefault();
        PostMessageToDiscord(document.getElementById("modInputText").value, serverConfig.modmessage_channel);
        document.getElementById("modInputText").value = ""
    }
    // ============================================================================
    //                           FUNCTION: RequestSongLists
    // ============================================================================
    function RequestSongLists ()
    {
        sr_api.sendMessage(DataCenterSocket,
            sr_api.ServerPacket("ExtensionMessage",
                serverConfig.extensionname,
                sr_api.ExtensionPacket(
                    "RequestSonglist",
                    serverConfig.extensionname,
                    "",
                    "",
                    "streamersonglist"),
                "",
                "streamersonglist"
            ));
        sr_api.sendMessage(DataCenterSocket,
            sr_api.ServerPacket("ExtensionMessage",
                serverConfig.extensionname,
                sr_api.ExtensionPacket(
                    "RequestQueue",
                    serverConfig.extensionname,
                    "",
                    "",
                    "streamersonglist"),
                "",
                "streamersonglist"
            ));
    }

    // ============================================================================
    //                           FUNCTION: RquestPhilipsHueData
    // ============================================================================
    function RquestPhilipsHueData ()
    {
        sr_api.sendMessage(DataCenterSocket,
            sr_api.ServerPacket("ExtensionMessage",
                serverConfig.extensionname,
                sr_api.ExtensionPacket(
                    "GetAllScenes",
                    serverConfig.extensionname,
                    "",
                    "",
                    "philipshue"),
                "",
                "philipshue"
            ));
    }
    // ============================================================================
    //                           FUNCTION: RequestRandomFact
    // ============================================================================
    function RequestRandomFact ()
    {
        sr_api.sendMessage(DataCenterSocket,
            sr_api.ServerPacket("ExtensionMessage",
                serverConfig.extensionname,
                sr_api.ExtensionPacket(
                    "action_RequestRandomFact",
                    serverConfig.extensionname,
                    "",
                    {},
                    "randomfact"),
                "",
                "randomfact"
            ));
    }
    // ============================================================================
    //                           FUNCTION: processRandomFact
    // ============================================================================
    function processRandomFact (data)
    {
        localConfig.randomFact = data;
    }
    // ============================================================================
    //                           FUNCTION: processTimers
    // ============================================================================
    function processTimers (data)
    {
        localConfig.timers[data.name] = data.timeout
    }

    // ============================================================================
    //                           FUNCTION: twitchFactOfTheDay
    // ============================================================================
    function twitchFactOfTheDay ()
    {
        if (localConfig.twitchRandomFactHandle != null)
            clearTimeout(localConfig.twitchRandomFactHandle);

        localConfig.twitchRandomFactHandle = setTimeout(function ()
        {
            if (localConfig.randomFact != "")
                postMessageToTwitch("Random Fact: " + localConfig.randomFact, "bot")
            RequestRandomFact();
            twitchFactOfTheDay();

        },
            serverConfig.randomfactstimeout
        )

    }
    // ============================================================================
    //                           FUNCTION: addSongToStreamersonglistQueue
    // ============================================================================
    function addSongToStreamersonglistQueue (songId)
    {
        sr_api.sendMessage(DataCenterSocket,
            sr_api.ServerPacket("ExtensionMessage",
                serverConfig.extensionname,
                sr_api.ExtensionPacket(
                    "action_AddSongToQueue",
                    serverConfig.extensionname,
                    songId,
                    "",
                    "streamersonglist"),
                "",
                "streamersonglist"
            ));
    }
    // ============================================================================
    //                           FUNCTION: removeSongFromQueue
    // ============================================================================
    function removeSongFromQueue (queueId)
    {
        let classes = "bg-light text-dark"
        if (modeDark)
            classes = "bg-dark text-light"
        $("#queue_" + queueId + "_remove").addClass("btn-warning").removeClass(classes)
        sr_api.sendMessage(DataCenterSocket,
            sr_api.ServerPacket("ExtensionMessage",
                serverConfig.extensionname,
                sr_api.ExtensionPacket(
                    "RemoveSongFromQueue",
                    serverConfig.extensionname,
                    queueId,
                    "",
                    "streamersonglist"),
                "",
                "streamersonglist"
            ));
    }
    // ============================================================================
    //                           FUNCTION: markSongAsPlayed
    // ============================================================================
    function markSongAsPlayed (queueId)
    {
        let classes = "bg-light text-dark"
        if (modeDark)
            classes = "bg-dark text-light"
        $("#queue_" + queueId + "_played").addClass("btn-warning").removeClass(classes)
        sr_api.sendMessage(DataCenterSocket,
            sr_api.ServerPacket("ExtensionMessage",
                serverConfig.extensionname,
                sr_api.ExtensionPacket(
                    "action_MarkSongAsPlayed",
                    serverConfig.extensionname,
                    queueId,
                    "",
                    "streamersonglist"),
                "",
                "streamersonglist"
            ));
    }
    // ============================================================================
    //                           FUNCTION: updateSingerSonglistQueue
    // ============================================================================
    function updateSingerSonglistQueue (queue)
    {
        const tabletitle = document.getElementById("streamersonglisttitle");
        const queueTableBody = document.querySelector('#queueTableBody');
        queueTableBody.innerHTML = '';
        let tableentry = "";
        let song = "";
        let songtime = "";
        let displaytime = "";
        let classes = "bg-light text-dark";
        if (modeDark == "true")
            classes = "bg-dark text-light"

        // if we havent been passed an array just use the stored one (might just be a refresh)
        if (queue != [] && queue !== undefined)
            localConfig.setreamersonglist.queue = queue;

        tabletitle.innerHTML = "Song Queue (played today: " + localConfig.setreamersonglist.queue.status.songsPlayedToday
            + ", in Queue: " + localConfig.setreamersonglist.queue.list.length + ")"
        localConfig.setreamersonglist.queue.list.forEach((entry) =>
        {
            if (song != null)
            {
                song = entry.song
                songtime = (new Date(entry.createdAt))
                displaytime = songtime.getHours() + ":" + songtime.getMinutes().toString().padStart(2, '0')

                tableentry += "<tr class = '" + classes + "'>"
                tableentry += "<td>" + displaytime + "</td>";
                tableentry += "<td>" + song.title + "</td>";
                tableentry += "<td>" + song.artist + "</td>";
                tableentry += "<td>" + (song.capo ? song.capo : "None") + "</td>";
                // number of entries in the queue
                tableentry += "<td>" + localConfig.setreamersonglist.queue.list.filter((v) => (v.songId === entry.songId)).length + "</td>";
                tableentry += "<td>" + entry.requests[0].name + "</td>";
                tableentry += "<td>" + entry.requests[0].inChat + "</td>";//inchat
                tableentry += "<td " + (entry.donationAmount > 0 ? "style = 'background: rgb(208 0 255)'" : "") + ">" + entry.donationAmount + "</td>";//$

                // mark as played button
                tableentry += "<td><button id='queue_" + entry.id + "_played'class='btn " + classes + "' style='border:1px solid rgb(174, 255, 0)' onclick='markSongAsPlayed(" + entry.id + ")'>Played</button>";
                // delete button
                tableentry += "<button id='queue_" + entry.id + "_remove' class='btn " + classes + "' style='border:1px solid rgb(174, 50, 0)' onclick='removeSongFromQueue(" + entry.id + ")'>Remove</button>"
                tableentry += "</td>";
                tableentry += "</tr>"
            }
            else
            {
                //console.log("Empty list song")
            }
        });

        queueTableBody.innerHTML = tableentry;
    }
    // ============================================================================
    //                           FUNCTION: updateSingerSonglistList
    // ============================================================================
    function updateSingerSonglistList (songlist)
    {
        localConfig.setreamersonglist.songlist = songlist;
    }
    // ============================================================================
    //                Songlist Autocomplete listener function
    // ============================================================================
    document.addEventListener("DOMContentLoaded", () => 
    {
        //add handler for when user types something
        $('#autocomplete-input').on('input', function ()
        {
            var input = $(this).val().toLowerCase();
            var autocompleteList = $('#autocomplete-list');
            // how many items to show in list
            var numbertodisplay = 5;
            autocompleteList.empty();

            if (input.length === 0)
                return;

            localConfig.setreamersonglist.songlist.some(function (item)
            {
                var itemLowerCase = item.title.toLowerCase();
                if (itemLowerCase.indexOf(input) !== -1)
                {
                    var listItem = $('<a id="songlistsearch" href="#songlistsearch" class="list-group-item list-group-item-action"></a>');
                    listItem.text(item.title);
                    listItem.on('click', function ()
                    {
                        $('#autocomplete-input').val("");
                        addSongToStreamersonglistQueue(item.id)
                        autocompleteList.empty();
                    });

                    autocompleteList.append(listItem);
                    numbertodisplay--;
                    if (numbertodisplay < 1)
                        return true

                }
            });
        });
    });
    // ============================================================================
    //                           FUNCTION: deadMansHeartBeatCallback
    // parse received heartbeats from extensions
    // ============================================================================
    function deadMansHeartBeatCallback ()
    {
        if (DataCenterSocket.connected)
        {
            document.getElementById('shutdownbutton').classList.add("btn-success");
            document.getElementById('shutdownbutton').classList.remove("btn-danger");
            document.getElementById('shutdownbutton').style.color = "green";
            document.getElementById('shutdownbuttonsvg').style.fill = "green"
        }
        else
        {
            document.getElementById('shutdownbutton').classList.add("btn-danger");
            document.getElementById('shutdownbutton').classList.remove("btn-success");
            document.getElementById('shutdownbutton').style.color = "red"
            document.getElementById('shutdownbuttonsvg').style.fill = "red"
        }
        localConfig.deadmansHeartBeatHandle = setTimeout(deadMansHeartBeatCallback, localConfig.deadmansHeartBeatTimeout)
    }
    // ============================================================================
    //                           FUNCTION: Power Button
    // ============================================================================
    const powerbutton = document.getElementById('shutdownbutton_menu')
    powerbutton.addEventListener('click', function (e)
    {
        e.preventDefault(); // cancel the link behaviour
        sr_api.sendMessage(DataCenterSocket,
            sr_api.ServerPacket(e.target.text,
                serverConfig.extensionname,
                e.target.text,
                "",
                ""
            ));
    });

    // ============================================================================
    //                           FUNCTION: setCardsVisibility
    // ============================================================================
    function setCardsVisibility ()
    {
        let card = document.getElementById("StreamerSongListCard");
        (serverConfig.streamersonglistdisplay == "on") ? (card.style.display = "block") : (card.style.display = "none");

        card = document.getElementById("ModMessagesCard");
        (serverConfig.discordmodchatdisplay == "on") ? (card.style.display = "block") : (card.style.display = "none");

        card = document.getElementById("OBSControllsCard");
        (serverConfig.obsdisplay == "on") ? (card.style.display = "block") : (card.style.display = "none");

        card = document.getElementById("PhilipsHueCard");
        (serverConfig.philipshuedisplay == "on") ? (card.style.display = "block") : (card.style.display = "none");

        card = document.getElementById("MacroButtonsCard");
        (serverConfig.macrobuttonsdisplay == "on") ? (card.style.display = "block") : (card.style.display = "none");

        card = document.getElementById("AlertsCard");
        (serverConfig.slalertsdisplay == "on") ? (card.style.display = "block") : (card.style.display = "none");

    }

    // ============================================================================
    //                           FUNCTION: processPhilipsHueScenes
    // ============================================================================
    function processPhilipsHueScenes ()
    {
        updatePhilipsHueDisplay()
    }
    // ============================================================================
    //                           FUNCTION: activatePhilipsHueScene
    // ============================================================================
    function activatePhilipsHueScene (sceneId)
    {
        sr_api.sendMessage(DataCenterSocket,
            sr_api.ServerPacket("ExtensionMessage",
                serverConfig.extensionname,
                sr_api.ExtensionPacket(
                    "action_ActivateScene",
                    serverConfig.extensionname,
                    {
                        sceneID: sceneId
                    },
                    "",
                    "philipshue"),
                "",
                "philipshue"
            ));
    }
    // ============================================================================
    //                           FUNCTION: updatePhilipsHueDisplay
    // ============================================================================
    function updatePhilipsHueDisplay ()
    {
        // let card = document.getElementById("PhilipsHueCard");
        let scenesrow = document.getElementById("PhilipsHueScenesRow");
        let rowdata = ""
        let btnstate = "btn-outline-secondary";
        // need to update this to show the current active scene when we know what kind of data we are getting
        let first = true

        if (localConfig.philipsHueSceneList && localConfig.philipsHueSceneList.length > 0)
        {
            localConfig.philipsHueSceneList.forEach((element) =>
            {
                if (first)
                {
                    btnstate = "btn-outline-success";
                    first = false
                }
                else
                    btnstate = "btn-outline-secondary"
                rowdata += '<div id="PhilipsHueScene_' + element.id + '" class="col-1 btn ' + btnstate + ' mx-1 my-1" role="button" data-toggle="tooltip" onclick="activatePhilipsHueScene(\'' + element.id + '\')" title="Scene Name">' + element.name + '</div>';
            })
        }
        else
            rowdata += '<div id="PhilipsHueScene_no_scense_available" class="col-1 btn ' + btnstate + ' mx-1 my-1" role="button" data-toggle="tooltip" title="Scene Name">No Scenes availabe</div>';
        document.getElementById("PhilipsHueScenesRow").innerHTML = rowdata;
    }
    // ============================================================================
    //                           FUNCTION: activateMacro
    // ============================================================================
    function activateMacro (Id)
    {
        if (typeof (localConfig.macros[Id]) != "undefined")
        {
            sr_api.sendMessage(DataCenterSocket,
                sr_api.ServerPacket("ExtensionMessage",
                    serverConfig.extensionname,
                    sr_api.ExtensionPacket(
                        "action_ActivateMacro",
                        serverConfig.extensionname,
                        localConfig.macros[Id],
                        "",
                        "autopilot"),
                    "",
                    "autopilot"
                ),
            );
        }
    }
    // ============================================================================
    //                           FUNCTION: banUserClicked
    // ============================================================================
    function banUserClicked (username)
    {
        let reason = prompt("Ban " + username + "?", "Chat Spam")
        if (reason != null)
        {
            if (!localConfig.bannedUsersList.includes(username))
            {
                localConfig.bannedUsersList.push(username);
                // request the twitch chat buffer so our display code will update the icons correctly
                RequestChatBuffer("twitchchat");

                sr_api.sendMessage(DataCenterSocket,
                    sr_api.ServerPacket("ExtensionMessage",
                        serverConfig.extensionname,
                        sr_api.ExtensionPacket(
                            "action_TwitchBan",
                            serverConfig.extensionname,
                            { user: username, reason: reason },
                            "",
                            "twitch"),
                        "",
                        "twitch"
                    ),
                );
            }
        }
    }
    // ============================================================================
    //                           FUNCTION: banUserClicked
    // ============================================================================
    function unBanUserClicked (username)
    {
        if (localConfig.bannedUsersList.includes(username))
        {
            localConfig.bannedUsersList.pop(username)
            // request the twitch chat buffer so our display code will update the icons correctly
            RequestChatBuffer("twitchchat");

            sr_api.sendMessage(DataCenterSocket,
                sr_api.ServerPacket("ExtensionMessage",
                    serverConfig.extensionname,
                    sr_api.ExtensionPacket(
                        "action_TwitchUnban",
                        serverConfig.extensionname,
                        { user: username, reason: "unbanned by streamer" },
                        "",
                        "twitch"),
                    "",
                    "twitch"
                ),
            );
        }
    }

    // ============================================================================
    //                           FUNCTION: updateMacroButtonsDisplay
    // ============================================================================
    function updateMacroButtonsDisplay (data)
    {
        // let card = document.getElementById("MacroButtonsCard");
        let scenesrow = document.getElementById("MacroButtonsRow");
        let rowdata = ""
        let macrolist = data
        // need to update this to show the current active scene when we know what kind of data we are getting
        let first = true
        let color = ""
        let backgroundcolor = ""

        if (macrolist && macrolist.length > 0)
        {
            for (let i = 0; i < macrolist.length; i++)
            {
                let macroName = macrolist[i].name;
                let macroDescription = macrolist[i].description;
                let macroImage = macrolist[i].image;
                if (macrolist[i].color != "")
                    color = macrolist[i].color
                if (macrolist[i].backgroundcolor != "")
                    backgroundcolor = macrolist[i].backgroundcolor
                if (typeof (macroImage) != "undefined" && macroImage != "")
                {
                    rowdata += "<div class='deckiconslot'>"
                    rowdata += "<img class='deckicon' src='/autopilot/images/deckicons/" + macroImage + "' alt = '" + macroName + ": " + macroDescription + "' onclick='activateMacro(\"" + i + "\");' title='" + macroName + ": " + macroDescription + "'>"
                    rowdata += "</div>"
                }
                else
                {
                    rowdata += "<div class='deckiconslot'>"
                    rowdata += "<div class='nodeckicon' style='color:" + color + "; background-color:" + backgroundcolor + ";' alt='" + macroName + "' onclick='javascript:activateMacro(\"" + i + "\");'  title='" + macroName + ": " + macroDescription + "'>" + macroName + "</div> "
                    rowdata += "</div>"
                }
            }
        }
        else
            rowdata += '<div id="MacroButtons_no_scense_available" class="col-1 btn btn-outline-secondary mx-1 my-1" role="button" data-toggle="tooltip" title="Scene Name">No Macros availabe</div>';
        rowdata += "</div>"
        document.getElementById("MacroButtonsRow").innerHTML = rowdata;
    }
    // ============================================================================
    //                           FUNCTION: checkForNewSoftwareVersion
    // ============================================================================
    function checkForNewSoftwareVersion ()
    {
        let url = "https://api.github.com/repos/SilenusTA/StreamRoller/tags";
        $.getJSON(url, function (allTags)
        {
            for (let i = 0; i < allTags.length; i++)
            {
                //find the first version tag
                if (allTags[i].name.indexOf("v") == 0)
                {
                    let tag = allTags[i]
                    localConfig.latestRelease =
                    {
                        "name": tag.name,
                        "exe": "https://github.com/SilenusTA/StreamRoller/releases/download/" + tag.name + "/StreamRoller" + tag.name + ".exe",
                        "zip": "https://github.com/SilenusTA/StreamRoller/releases/download/" + tag.name + "/StreamRoller" + tag.name + ".zip"

                    }
                    processLatestRelease()
                    break;
                }
            }
        });

    }
    // ============================================================================
    //                           FUNCTION: processLatestRelease
    // ============================================================================
    function processLatestRelease ()
    {
        let swVersionHtml = ""
        if (!localConfig.softwareVersion.startsWith(localConfig.latestRelease.name))
        {
            swVersionHtml += "<div class='text-warning'>"
            //$("#softwareversion").append(
            swVersionHtml += " Sofware Update Available"
            swVersionHtml += " zip: <a href='" + localConfig.latestRelease.zip + "'>" + localConfig.latestRelease.name + "</a>"
            swVersionHtml += " | exe: <a href='" + localConfig.latestRelease.exe + "'>" + localConfig.latestRelease.name + "</a>"
            swVersionHtml += "</div>"
            document.getElementById("softwareversion").innerHTML = swVersionHtml
        }
    }
    // ============================================================================
    //                     FUNCTION: getFileNameDateString
    // ============================================================================
    function getFileNameDateString ()
    {
        // returns a suitable date string for appending to a filename
        const date = new Date();
        const year = date.getFullYear();
        const month = (date.getMonth() + 1).padStart(2, '0');
        const day = (date.getDate()).padStart(2, '0');
        const hours = (date.getHours()).padStart(2, '0');
        const minutes = (date.getMinutes()).padStart(2, '0');
        const seconds = (date.getSeconds()).padStart(2, '0');
        return year + "_" + month + "_" + day + "-" + hours + "_" + minutes + "_" + seconds
    }
</script>