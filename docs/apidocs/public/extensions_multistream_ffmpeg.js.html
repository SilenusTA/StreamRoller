<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, 
                      width=device-width, initial-scale=1.0, 
                      minimum-scale=1.0, maximum-scale=1.0, 
                      user-scalable=no, target-densitydpi=device-dpi">
    <title>Source: extensions/multistream/ffmpeg.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head data-theme="light">

<body>
    <div id="page-nav-bar">
        <div><a id="top-icon" href="#"></a></div>
        <div id="toggle-theme"
        data-theme-toggle
        aria-label="Change to light theme"
    >Change to light theme (or icon here)</div>
</div>
<script>

    // get theme on startup
    const localStorageTheme = localStorage.getItem("theme");
    const systemSettingDark = window.matchMedia("(prefers-color-scheme: dark)");
    let currentThemeSetting = calculateSettingAsThemeString({ localStorageTheme, systemSettingDark });
    
    ///////////////////////////////////////////////////////////////////
    /////////////////calculateSettingAsThemeString/////////////////////
    ///////////////////////////////////////////////////////////////////
    function calculateSettingAsThemeString({ localStorageTheme, systemSettingDark }) 
    {
        if (localStorageTheme !== null) {
            return localStorageTheme;
        }
        if (systemSettingDark.matches) {
            return "dark";
        }
        return "light";
    }
    const themeEle = document.querySelector("[data-theme-toggle]");
    const topIcon = document.getElementById("top-icon");
    themeEle.addEventListener("click", () => {toggleTheme()});
    

    /////////////////////////////////////////////////
    /////////////////toggleTheme/////////////////////
    /////////////////////////////////////////////////
    function toggleTheme()
    {
        const newTheme = currentThemeSetting === "dark" ? "light" : "dark";
        // update in local storage
        localStorage.setItem("theme", newTheme);

        // update the currentThemeSetting in memory
        currentThemeSetting = newTheme;

        setTheme();
    }
    //////////////////////////////////////////////
    /////////////////setTheme/////////////////////
    //////////////////////////////////////////////
    function setTheme()
    {
        // update the button text
        const newImage = currentThemeSetting === "dark" ? dayicon() : nighticon();
        const newCta = currentThemeSetting === "dark" ? "Light Theme" : "Dark Theme";
        //themeEle.innerText = newCta;  
        themeEle.innerHTML = newImage;  
        topIcon.innerHTML = topicon();
        // use an aria-label if you are omitting text on the button
        // and using sun/moon icons, for example
        themeEle.setAttribute("aria-label", newCta);

        // update theme attribute on HTML to switch theme in CSS
        document.querySelector("html").setAttribute("data-theme", currentThemeSetting);
    }

    function dayicon(tag)
    {
        return `
        <svg xmlns="http://www.w3.org/2000/svg" 
        viewBox="0 0 24 24" 
        fill="none" 
        stroke="currentColor" 
        stroke-linecap="round" 
        stroke-linejoin="round" 
        width="24" height="24" 
        stroke-width="2"> 
        <path d="M14.828 14.828a4 4 0 1 0 -5.656 -5.656a4 4 0 0 0 5.656 5.656z"></path> 
        <path d="M6.343 17.657l-1.414 1.414"></path> 
        <path d="M6.343 6.343l-1.414 -1.414"></path> 
        <path d="M17.657 6.343l1.414 -1.414"></path> 
        <path d="M17.657 17.657l1.414 1.414"></path> 
        <path d="M4 12h-2"></path> 
        <path d="M12 4v-2"></path> 
        <path d="M20 12h2"></path> 
        <path d="M12 20v2"></path> 
        </svg>`
    }
    function nighticon(tag)
    {
        return`
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="24" height="24">
        <path d="M12 19a1 1 0 0 1 .993 .883l.007 .117v1a1 1 0 0 1 -1.993 .117l-.007 -.117v-1a1 1 0 0 1 1 -1z"></path>
        <path d="M18.313 16.91l.094 .083l.7 .7a1 1 0 0 1 -1.32 1.497l-.094 -.083l-.7 -.7a1 1 0 0 1 1.218 -1.567l.102 .07z"></path>
        <path d="M7.007 16.993a1 1 0 0 1 .083 1.32l-.083 .094l-.7 .7a1 1 0 0 1 -1.497 -1.32l.083 -.094l.7 -.7a1 1 0 0 1 1.414 0z"></path>
        <path d="M4 11a1 1 0 0 1 .117 1.993l-.117 .007h-1a1 1 0 0 1 -.117 -1.993l.117 -.007h1z"></path>
        <path d="M21 11a1 1 0 0 1 .117 1.993l-.117 .007h-1a1 1 0 0 1 -.117 -1.993l.117 -.007h1z"></path>
        <path d="M6.213 4.81l.094 .083l.7 .7a1 1 0 0 1 -1.32 1.497l-.094 -.083l-.7 -.7a1 1 0 0 1 1.217 -1.567l.102 .07z"></path>
        <path d="M19.107 4.893a1 1 0 0 1 .083 1.32l-.083 .094l-.7 .7a1 1 0 0 1 -1.497 -1.32l.083 -.094l.7 -.7a1 1 0 0 1 1.414 0z"></path>
        <path d="M12 2a1 1 0 0 1 .993 .883l.007 .117v1a1 1 0 0 1 -1.993 .117l-.007 -.117v-1a1 1 0 0 1 1 -1z"></path>
        <path d="M12 7a5 5 0 1 1 -4.995 5.217l-.005 -.217l.005 -.217a5 5 0 0 1 4.995 -4.783z"></path>
        </svg>`
    }
    function topicon()
    {
        //from https://tablericons.com/
        return `
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" width="24" height="24" stroke-width="2"> <path d="M12 10l0 10"></path> <path d="M12 10l4 4"></path> <path d="M12 10l-4 4"></path> <path d="M4 4l16 0"></path> </svg> `
    }
    
    // set the theme on page load
    setTheme()
</script>

<div id="main">

    <h1 class="page-title">Source: extensions/multistream/ffmpeg.js</h1>

    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Copyright (C) 2025 "SilenusTA https://www.twitch.tv/olddepressedgamer"
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 * 
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see &lt;https://www.gnu.org/licenses/>.
 */
import commandExists from 'command-exists';
import axios from 'axios';
import process from 'process';
import * as fs from "fs";
import { exec, spawn, spawnSync } from "node:child_process";
import * as logger from "../../backend/data_center/modules/logger.js";
import { dirname } from 'path';
import { fileURLToPath } from 'url';
const __dirname = dirname(fileURLToPath(import.meta.url));

const localConfig = {
    // ############### Streamroller stuff
    SYSTEM_LOGGING_TAG: "[EXTENSION]",
    extensionname: "multistream",
    // Ensure we wait for captured streams to end before calling endCB
    exitError: null,
    // Buffers and flags
    stdoutBuffer: [],
    stderrBuffer: [],
    exitFlags: [],
    debugOptions: {},
    busyFlags: [],

    // ffmpeg command 
    // installed version of ffmpeg available/installed/selected
    ffmpegVersion: "",
    streamRollerFfmpegInstalled: false,
    userFfmpegInstalled: false,
    useStreamRollerFfmpeg: false,//use/install ffmpeg in bin dir

    // encoder stuff
    ffmpegEncodersString: null,
    encoderFileName: "data/encoders.json",
    audioEncoders: {},
    videoEncoders: {},


    // download options for ffmpeg
    ffmpegDownloadURL: "https://github.com/BtbN/FFmpeg-Builds/releases/download/latest/ffmpeg-master-latest-win64-gpl-shared.zip",
    ffmpegFolder: __dirname + "\\bin\\",
    ffmpegDownloadZip: __dirname + "\\bin\\ffmpeg.zip",
    ffmpegExe: __dirname + "\\bin\\ffmpeg.exe",
    ffmpegHandle: null,

    // ################ Timer Handles
    encoderBuildTimeout: 10000,
    encoderBuildTimeoutHandle: null,
    // timer handle to wait for UpdateEncodersAvailable() to finish before returning promises
    waitForUpdateEncodersAvailableTimeout: 500,
    waitForUpdateEncodersAvailableHandle: null,
    // encoders json file save handle (to avoid saving in the middle of an update)
    encodersFileSaveTimerTimeout: 500,
    encodersFileSaveTimerHandle: null,

    waitForParseEncodersStringTimeout: 500,
    waitForParseEncodersStringHandle: null,

    // ############### promise cache handles
    // promise handles so we can cache results rather than run multiple times
    UpdateEncodersAvailablePromiseCache: null,
    parseEncodersStringPromiseCache: null,
}
// ============================================================================
//                           FUNCTION: init
// ============================================================================
/**
 * 
 */
function init ()
{
    // setup monitoring flags
    localConfig.busyFlags.streaming = false;
    localConfig.busyFlags.getEncoders = false;
    localConfig.busyFlags.getEncoderOptions = 0;

    // setup debug options
    localConfig.debugOptions.DEBUG_FFMPEG = false;
    localConfig.debugOptions.DEBUG_FFMPEG_STDERR = false;
    localConfig.debugOptions.DEBUG_FFMPEG_STDOUT = false;

    //set process exited flags
    localConfig.exitFlags.processExited = true;
    localConfig.exitFlags.stdoutClosed = true;
    localConfig.exitFlags.stderrClosed = true;

    checkFFMPEGInstall();
}
// ============================================================================
//                           FUNCTION: useStreamRollerFfmpeg
// ============================================================================
/**
 * Should we use StreamRoller FFMPEG or the PC Installed one (if available)
 * @param {boolean} useStreamRoller 
 */
function useStreamRollerFfmpeg (useStreamRoller)
{
    localConfig.useStreamRollerFfmpeg = useStreamRoller;
}
// ============================================================================
//                           FUNCTION: getInstalledFFMPEGs
// ============================================================================
/**
 * Returns the types of FFMPEG we have installed (ie user or StreamRoller)
 * {streamRollerFfmpegInstalled,userFfmpegInstalled}
 */
function getInstalledFFMPEGs ()
{
    return {
        streamRollerFfmpegInstalled: localConfig.streamRollerFfmpegInstalled,
        userFfmpegInstalled: localConfig.userFfmpegInstalled
    };
}
// ============================================================================
//                           FUNCTION: ffmpegBusyFlags
// ============================================================================
/**
 * checks if ffmpegBusyFlags processing is still happening, ie encoder queries etc
 * @returns boolean
 */
function ffmpegBusyFlags () 
{
    return localConfig.busyFlags;
    /*return (
        Object.values(localConfig.busyFlags).includes(true)
        || localConfig.busyFlags.getEncoderOptions > 0)
        ;
        */
}
// ============================================================================
//                           FUNCTION: runFFMPEG
// ============================================================================
/**
 * 
 * @param {string} command 
 * @param {array} args 
 * @param {object} options 
 * @param {callback} processCB 
 * @param {callback} streamStarted 
 * @param {callback} streamFinished 
 * @returns handle to process
 */
function runFFMPEG (command, args, options = {}, processCB = null, streamStarted = null, streamFinished = null)
{
    localConfig.exitFlags.processExited = false;
    let ffmpegProc = spawn(command, args, options);
    localConfig.busyFlags.streaming = true;
    if (localConfig.debugOptions.DEBUG_FFMPEG)
        console.log("ffmpegProc ", command, args.join(' '));

    ffmpegProc.on('error', function (err)
    {
        localConfig.exitFlags.processExited = true;
        localConfig.busyFlags.streaming = false;
        console.log("ffmpegProc:error()", err)
        streamFinished(err);
    });

    ffmpegProc.on('exit', function (code, signal)
    {
        if (signal)
        {
            if (localConfig.debugOptions.DEBUG_FFMPEG)
                console.log("ffmpeg:exit()was killed with signal " + signal.toString());

        } else if (code)
        {
            console.log("ffmpeg:exit()exited with code " + code.toString());
        } else
        {
            if (localConfig.debugOptions.DEBUG_FFMPEG)
                console.log("ffmpeg:exit()");
        }
        localConfig.exitFlags.processExited = true;
        localConfig.busyFlags.streaming = false;
        streamFinished();
    });

    // Capture stdout buffer
    ffmpegProc.stdout.on('data', function (data)
    {
        localConfig.exitFlags.stdoutClosed = false;
        localConfig.busyFlags.streaming = true;
        localConfig.stdoutBuffer.push(data.toString())
    });

    ffmpegProc.stdout.on('close', function ()
    {
        localConfig.exitFlags.stdoutClosed = true
        localConfig.busyFlags.streaming = false;
        if (localConfig.debugOptions.DEBUG_FFMPEG_STDOUT)
            console.log("ffmpeg:stdout:close")
        handleExit(null, streamFinished);
    });

    // Capture stderr buffer
    ffmpegProc.stderr.on('data', function (data)
    {
        localConfig.exitFlags.stderrClosed = false
        localConfig.busyFlags.streaming = true;
        localConfig.stderrBuffer.push(data.toString())
        // on first data we notify stream is running so we can start OBS etc
        if (!localConfig.streamRunning)
            streamStarted();
        if (localConfig.debugOptions.DEBUG_FFMPEG_STDERR)
            console.log("ffmpeg:stderr:data()", JSON.stringify(data.toString(), null, 2))
    });

    ffmpegProc.stderr.on('close', function ()
    {
        //stderrBuffer.push('close')
        if (localConfig.debugOptions.DEBUG_FFMPEG_STDERR)
            console.log("ffmpeg:stderr:close()")
        localConfig.exitFlags.stderrClosed = true;
        localConfig.busyFlags.streaming = false;
        handleExit(null, streamFinished);
    });

    // Call process callback
    processCB(ffmpegProc);
    return ffmpegProc;
}
// ============================================================================
//                           FUNCTION: handleExit
// ============================================================================
/**
 * 
 * @param {error} err 
 * @param {callback} endCB 
 */
function handleExit (err, endCB)
{
    if (localConfig.debugOptions.DEBUG_FFMPEG)
        console.log(`handleExit(${err},endCB())`)
    let exitError = null;
    if (err)
    {
        exitError = err;
    }

    if (localConfig.exitFlags.processExited &amp;&amp; (localConfig.exitFlags.stdoutClosed) &amp;&amp; localConfig.exitFlags.stderrClosed)
    {
        endCB(exitError, localConfig.exitFlags.stdoutBuffer, localConfig.exitFlags.stderrBuffer);
    }
}
// ============================================================================
//                           FUNCTION: setDebug
// ============================================================================
/**
 * 
 * @param {object} debugOptions 
 */
function setDebug (debugOptions)
{
    localConfig.debugOptions = debugOptions
}
// ============================================================================
//                           FUNCTION: getDebug
// ============================================================================
/**
 * 
 * @returns object
 */
function getDebug ()
{
    return localConfig.debugOptions
}
// ============================================================================
//                           FUNCTION: getEncoders
// ============================================================================
/**
 * 
 * @returns object 
 */
function getEncoders ()
{
    return { videoEncoders: localConfig.videoEncoders, audioEncoders: localConfig.audioEncoders }
}
// ============================================================================
//                      FUNCTION: UpdateEncodersAvailable
// ============================================================================
/**
 * Query the Computer for ffmpeg encoders
 * @returns Promise with encoders object when resolved or null 
 */
function UpdateEncodersAvailable ()
{
    if (localConfig.debugOptions.DEBUG_FFMPEG)
        console.log("UpdateEncodersAvailable ()")
    let ffmpegExe = getFFMPEGCommand()
    // if we already have an instance running then return that promise
    // this will effectively cache calls to this function for multiple users
    if (!localConfig.UpdateEncodersAvailablePromiseCache)
    {
        localConfig.UpdateEncodersAvailablePromiseCache = new Promise((resolve, reject) =>
        {
            let finished = false;
            let timeout = false;
            let uptoEncoders = false;
            localConfig.busyFlags.getEncoders = true;
            // just in case the command fails or we don't finish early enough lets kill it after 10 seconds
            if (!localConfig.encoderBuildTimeoutHandle)
            {
                localConfig.encoderBuildTimeoutHandle = setTimeout(() =>
                {
                    console.log("Encoder query taking too long, Exiting")
                    timeout = true;
                }, localConfig.encoderBuildTimeout)
            }
            //let args = ["-hide_banner"];
            //need the banner to get the version line
            let args = ["-encoders"];
            let ffmpegHandle = spawn(ffmpegExe, args);
            localConfig.ffmpegEncodersString = "";

            if (ffmpegHandle.stderr)
                ffmpegHandle.stderr.setEncoding('utf8');
            if (ffmpegHandle.stdout)
                ffmpegHandle.stdout.setEncoding('utf8');

            ffmpegHandle.on('error', function (err)
            {
                console.log("UpdateEncodersAvailable():error()", err)
            });

            ffmpegHandle.on('exit', function (code, signal)
            {
                clearTimeout(localConfig.encoderBuildTimeoutHandle)
                localConfig.encoderBuildTimeoutHandle = null;
                finished = true;
                if (signal)
                    console.log("UpdateEncodersAvailable():exit()was killed with signal " + signal);
                else if (code)
                    console.log("UpdateEncodersAvailable():exit())exited with code " + code);
                //console.log("exit called no code or signal")
            });

            ffmpegHandle.stdout.on('data', function (data)
            {
                //console.log("stdout:adding data")
                let text = data.toString()
                if (text.indexOf("Encoders:") == 0)
                    uptoEncoders = true;

                if (uptoEncoders)
                    localConfig.ffmpegEncodersString += text
            });

            ffmpegHandle.stdout.on('close', function ()
            {
                if (localConfig.debugOptions.DEBUG_FFMPEG_STDOUT)
                    console.log("UpdateEncodersAvailable():stdout:close()")
            });
            // Capture stderr if specified
            ffmpegHandle.stderr.on('data', function (data)
            {
                // get the version number
                let text = data.toString()
                if (text.indexOf("ffmpeg version") == 0)
                    localConfig.ffmpegVersion = text.split('\n')[0].replace("\r", "")
                //console.log("stdout:adding:stderr:", data)
            })

            ffmpegHandle.stderr.on('close', function ()
            {
                if (localConfig.debugOptions.DEBUG_FFMPEG_STDERR)
                    console.log("UpdateEncodersAvailable():stderr:close()")
            });
            let count = 0;
            localConfig.waitForUpdateEncodersAvailableHandle = setInterval(async () =>
            {
                if (localConfig.debugOptions.DEBUG_FFMPEG)
                    console.log("waiting for exit", count++, finished, timeout)
                if (finished || timeout)
                {
                    if (timeout)
                        if (localConfig.debugOptions.DEBUG_FFMPEG)
                            console.log("UpdateEncodersAvailable():Encoder search timed out")
                    finished = false;
                    clearInterval(localConfig.waitForUpdateEncodersAvailableHandle)
                    await parseEncodersString(ffmpegExe);
                    localConfig.busyFlags.getEncoders = false;
                    if (timeout)
                        reject(null)
                    else
                    {
                        updateEncoderWebJSONFile();
                        resolve(true);
                    }
                }
            }, localConfig.waitForUpdateEncodersAvailableTimeout);
        })
    }
    return localConfig.UpdateEncodersAvailablePromiseCache;
}
// ============================================================================
//                           FUNCTION: parseEncodersString
// ============================================================================
/**
 * creates video and audio encoder lists from the ffmpeg output string
 * @param {string} ffmpegExe 
 * @returns Promise (true) or error
 */
async function parseEncodersString (ffmpegExe)
{
    if (!localConfig.parseEncodersStringPromiseCache)
    {
        localConfig.parseEncodersStringPromiseCache = new Promise((resolve, reject) =>
        {
            try
            {
                // clear out any old data
                localConfig.videoEncoders = {};
                localConfig.audioEncoders = {};
                let videoEncoderCounter = 0;
                let audioEncoderCounter = 0;
                const tempArray = localConfig.ffmpegEncodersString.split("\r\n")
                let postHeader = false;
                //scan lines
                for (let i = 0; i &lt; tempArray.length; i++)
                {
                    //skip to end of header
                    if (tempArray[i] == " ------")
                    {
                        postHeader = true;
                        continue;
                    }
                    if (!postHeader)
                        continue;
                    if (tempArray[i])
                    {
                        if (tempArray[i].indexOf(" V") == 0)
                        {
                            const videoEncoderName = tempArray[i].split(" ")[2];
                            if (videoEncoderName &amp;&amp; videoEncoderName != "")
                            {
                                videoEncoderCounter++;
                                localConfig.videoEncoders[videoEncoderName] = [];
                                getEncoderOptions(ffmpegExe, videoEncoderName)
                                    .then((opt) =>
                                    {
                                        videoEncoderCounter--;
                                        localConfig.videoEncoders[videoEncoderName] = opt;
                                    })
                            }
                        }
                        else if (tempArray[i].indexOf(" A") == 0)
                        {
                            const audioEncoderName = tempArray[i].split(" ")[2];
                            if (audioEncoderName &amp;&amp; audioEncoderName != "")
                            {
                                audioEncoderCounter++;
                                localConfig.audioEncoders[audioEncoderName] = [];
                                getEncoderOptions(ffmpegExe, audioEncoderName)
                                    .then((opt) =>
                                    {
                                        audioEncoderCounter--;
                                        localConfig.audioEncoders[audioEncoderName] = opt
                                    })
                            }
                        }
                    }
                }
                localConfig.waitForParseEncodersStringHandle = setInterval(async () =>
                {
                    if (videoEncoderCounter == 0 &amp;&amp; audioEncoderCounter == 0)
                    {
                        if (localConfig.debugOptions.DEBUG_FFMPEG)
                            console.log("parseEncodersString():finished")
                        clearInterval(localConfig.waitForParseEncodersStringHandle)
                        updateEncoderWebJSONFile();
                        resolve(true);
                    }
                }, localConfig.waitForParseEncodersStringTimeout);
            }
            catch (err)
            {
                console.log("parseEncodersString():err", err)
                reject(err)
            }
        })
    }
    //new addition
    return localConfig.parseEncodersStringPromiseCache;
}

// ============================================================================
//                           FUNCTION: getEncoderOptions
// ============================================================================
/**
 * 
 * @param {string} ffmpegExe 
 * @param {string} encoder 
 * @returns array of options for the given encoder
 */
async function getEncoderOptions (ffmpegExe, encoder)
{
    localConfig.busyFlags.getEncoderOptions++;
    return new Promise((resolve, reject) =>
    {
        exec(`${ffmpegExe} -hide_banner -h encoder=${encoder}`, (error, stdout, stderr) =>
        {
            if (error) return reject(`Error: ${stderr || error.message}`);
            let startParsing = false

            const options = { "none": "" };
            let optionName = ""
            const lines = stdout.split("\n");
            for (const line of lines)
            {
                if (line.includes("AVOptions"))
                {
                    startParsing = true
                    continue;
                }
                if (!startParsing)
                    continue;
                let regex = /^ {2}-(.+)/;
                let match = regex.test(line)
                if (match)
                {
                    let linearr = line.trim().replaceAll(/\s\s+/g, ' ').split(" ")
                    optionName = linearr[0]
                    //options[optionName] = "EMPTY"
                    options[optionName] = line.trim().replace(optionName, "").replace(linearr[2], "")
                }
            }
            localConfig.busyFlags.getEncoderOptions--;
            resolve(options);
        });
    });
}
// ============================================================================
//                           FUNCTION: updateEncoderWebJSONFile
// ============================================================================
/**
 * Updates the encoders file for the settings page
 */
function updateEncoderWebJSONFile ()
{
    // wait to save the file in case we are still processing
    if (Object.values(localConfig.busyFlags).includes(true)
        || localConfig.busyFlags.getEncoderOptions > 0)
    {
        // if we already have a time then skip setting a new one
        if (localConfig.encodersFileSaveTimerHandle)
            return
        else
        {
            localConfig.encodersFileSaveTimerHandle = setInterval(() =>
            {
                updateEncoderWebJSONFile();
            }, localConfig.encodersFileSaveTimerTimeout);
        }
    }
    else
    {
        clearInterval(localConfig.encodersFileSaveTimerHandle);
        localConfig.encodersFileSaveTimerHandle = null
        fs.writeFileSync(__dirname + "/" + localConfig.encoderFileName, JSON.stringify(
            {
                ffmpegVersion: localConfig.ffmpegVersion,
                videoEncoders: localConfig.videoEncoders,
                audioEncoders: localConfig.audioEncoders
            }))
    }
}
// ============================================================================
//                           FUNCTION: checkFFMPEGInstall
// ============================================================================
/**
 * checks what ffmpeg is installed and sets local variables 
 * (userFfmpegInstalled, streamRollerFfmpegInstalled)
 * to true or false based on availability
 */
function checkFFMPEGInstall ()
{
    // check if we have a cmd installed ffmpeg
    try
    {
        if (commandExists.sync("ffmpeg"))
            localConfig.userFfmpegInstalled = true;
        else
            localConfig.userFfmpegInstalled = false;
    }
    catch (err)
    {
        logger.err(localConfig.SYSTEM_LOGGING_TAG + localConfig.extensionname + ".initialise", "error while checking for ffmpeg:", err);
    }
    // check if we have a streamroller installed ffmpeg
    try
    {
        if (commandExists.sync(localConfig.ffmpegExe))
            localConfig.streamRollerFfmpegInstalled = true;
        else
            localConfig.streamRollerFfmpegInstalled = false;
    }
    catch (err)
    {
        logger.err(localConfig.SYSTEM_LOGGING_TAG + localConfig.extensionname + ".initialise", "error while checking for ffmpeg:", err);
    }
}
// ============================================================================
//                           FUNCTION: getFFMPEGCommand
// ============================================================================
/**
 * returns the cmd to run for the current ffmpeg setup
 * @returns ffmpeg exe command
 */
function getFFMPEGCommand ()
{
    let command = null
    if (localConfig.useStreamRollerFfmpeg)
    {
        if (localConfig.streamRollerFfmpegInstalled)
            command = localConfig.ffmpegExe;
        else
            logger.err(localConfig.SYSTEM_LOGGING_TAG + localConfig.extensionname +
                ".runFFMPEG", "Failed to find StreamRoller FFMPEG");
    }
    else
    {
        if (localConfig.userFfmpegInstalled)
            command = "ffmpeg.exe"
        else
            logger.err(localConfig.SYSTEM_LOGGING_TAG + localConfig.extensionname +
                ".runFFMPEG", "Failed to find System FFMPEG. Try running 'ffmpeg -version' on the command line to see if it is installed correctly");
    }
    return command;
}
// ############################################################################
//                            INSTALL FFMPEG FILES
// If the user doesn't have ffmpeg installed we can install one from github
// ############################################################################

// ============================================================================
//                           FUNCTION: downloadFFMPEG
// ============================================================================
/**
 * download and install ffmpeg
 */
async function downloadFFMPEG ()
{
    // check we have ffmpeg available or not.
    // inverted failure flag
    let installSuccess = true;

    // if we have a previous download lets delete it (should never be hit as should only run on install)
    if (fs.existsSync(localConfig.ffmpegDownloadZip))
    {
        fs.unlink(localConfig.ffmpegDownloadZip, (err) =>
        {
            if (err == null)
            {
                //console.log("finished deleting old ffmpeg download")
            }
            else
            { installSuccess = false; console.log("Error deleting previous ffmpeg download", err) }
        });
    }
    // download the zip and unpack it to the correct place
    axios({
        method: 'get',
        url: localConfig.ffmpegDownloadURL,
        responseType: 'stream',
        onDownloadProgress: progressEvent =>// print progress to in the console
        { printProgress("ffmpeg downloading " + Math.round((progressEvent.loaded * 100) / progressEvent.total) + "%") }
    }).then(response =>
    {
        //download complete write file
        const writer = fs.createWriteStream(localConfig.ffmpegDownloadZip);
        response.data.pipe(writer);
        writer.on('finish', async () => 
        {
            if (localConfig.debugOptions.DEBUG_FFMPEG)
                console.log('Download complete!');
            // unzip file
            if (localConfig.debugOptions.DEBUG_FFMPEG)
                console.log("unzipping file", localConfig.ffmpegDownloadZip, localConfig.ffmpegFolder)
            unzipfile(localConfig.ffmpegDownloadZip, localConfig.ffmpegFolder);
            if (localConfig.debugOptions.DEBUG_FFMPEG)
                console.log("unzipping finished")
            let files = [];
            try
            {
                files = fs.readdirSync(localConfig.ffmpegFolder + "ffmpeg-master-latest-win64-gpl-shared/bin")
            }
            catch (err)
            {
                installSuccess = false; logger.err(localConfig.SYSTEM_LOGGING_TAG + localConfig.extensionname + ":Error: loading ffmpeg files to copy", err);
            }

            // delete existing files we are about to copy
            files.forEach((value, index) =>
            {
                //delete existing file if it exists
                if (fs.existsSync(localConfig.ffmpegFolder + value))
                {
                    if (localConfig.debugOptions.DEBUG_FFMPEG)
                        console.log("deleteing", localConfig.ffmpegFolder + value)
                    try { fs.unlinkSync(localConfig.ffmpegFolder + value); }
                    catch (err) { installSuccess = false; logger.err(localConfig.SYSTEM_LOGGING_TAG + localConfig.extensionname + ":Error: clearing out old files before replacing", err); }
                }
            })
            // move new files in
            files.forEach((value, index) =>
            {
                if (localConfig.debugOptions.DEBUG_FFMPEG)
                    console.log("moving in new file", value)
                fs.renameSync(localConfig.ffmpegFolder + "ffmpeg-master-latest-win64-gpl-shared\\bin\\" + value,
                    localConfig.ffmpegFolder + value, function (err)
                {
                    if (err) { installSuccess = false; logger.err(localConfig.SYSTEM_LOGGING_TAG + localConfig.extensionname + ":Error: moving file ", localConfig.ffmpegFolder + "ffmpeg-master-latest-win64-gpl-shared\\bin\\" + value, err); }
                })
            })
            // delete downloaded files
            if (localConfig.debugOptions.DEBUG_FFMPEG)
                console.log("removing folder ffmpeg-master-latest-win64-gpl-shared")
            try { fs.rmSync(localConfig.ffmpegFolder + "ffmpeg-master-latest-win64-gpl-shared", { recursive: true, force: true }); }
            catch (err) { logger.err(localConfig.SYSTEM_LOGGING_TAG + localConfig.extensionname + ":Error: removing directory", localConfig.ffmpegFolder + "ffmpeg-master-latest-win64-gpl-shared", err); }

            // finally delete the zip file we downloaded
            if (fs.existsSync(localConfig.ffmpegDownloadZip))
            {
                try { fs.unlinkSync(localConfig.ffmpegDownloadZip); }
                catch (err) { logger.err(localConfig.SYSTEM_LOGGING_TAG + localConfig.extensionname + ":Error: clearing out downloaded ffmpeg.zip before replacing", err); }
            }
        });
        writer.on('error', err =>
        {
            installSuccess = false;
            console.error('Failed to download:', err)
        });
    })
        .catch(err =>
        {
            installSuccess = false;
            console.log("error downloading ffmpeg", err)
        })
    if (!installSuccess)
    {
        localConfig.StreamRollerFfmpeg = true;
        console.log('✅ FFMPEG Install complete!');
    }
    else
    {
        localConfig.StreamRollerFfmpeg = false;
        console.error('❌ FFMPEG Install Failed:')
    }
}
// ============================================================================
//                           FUNCTION: unzipfile
// ============================================================================
/**
 * 
 * @param {string} file filename
 * @param {to} to destination directory
 */
function unzipfile (file, to)
{
    let args = ["xf", file, "-C", to]
    let unzipHandle = spawnSync("tar", args);
    return unzipHandle;
}
// ============================================================================
//                           FUNCTION: printProgress
// ============================================================================
/**
 * overwrites a string on the cmd line, mostly useful for progress etc
 * @param {string} progress 
 */
function printProgress (progress)
{
    process.stdout.clearLine(0);
    process.stdout.cursorTo(0);
    process.stdout.write(progress);
}
// ============================================================================
//                           EXPORTS
// ============================================================================
export
{
    init,
    ffmpegBusyFlags,
    runFFMPEG,
    setDebug,
    getDebug,
    UpdateEncodersAvailable,
    useStreamRollerFfmpeg,
    getInstalledFFMPEGs,
    getFFMPEGCommand,
    getEncoders,
    downloadFFMPEG
}

</code></pre>
        </article>
    </section> 
</div>

<nav>
    <h2><a href="/index.html">StreamRoller Home</a></h2><h3><a href="/apidocs/index.html">API Docs</a></h3><h3>Extensions</h3><ul><li><a href="Adminpage_extension.html#Adminpage">Adminpage</a></li><li><a href="Autopilot_extension.html#Autopilot">Autopilot</a></li><li><a href="DiscordChat_extension.html#DiscordChat">DiscordChat</a></li><li><a href="FakeDeck_extension.html#FakeDeck">FakeDeck</a></li><li><a href="LivePortal_extension.html#LivePortal">LivePortal</a></li><li><a href="MSFS2020_extension.html#MSFS2020">MSFS2020</a></li><li><a href="OBS_extension.html#OBS">OBS</a></li><li><a href="PhilipsHue_extension.html#PhilipsHue">PhilipsHue</a></li><li><a href="Quizbot_extension.html#Quizbot">Quizbot</a></li><li><a href="RandomFact_extension.html#RandomFact">RandomFact</a></li><li><a href="StreamRoller_extension.html#StreamRoller">StreamRoller</a></li><li><a href="StreamerSongList_extension.html#StreamerSongList">StreamerSongList</a></li><li><a href="StreamlabsAPI_extension.html#StreamlabsAPI">StreamlabsAPI</a></li><li><a href="Sysinfo_extension.html#Sysinfo">Sysinfo</a></li><li><a href="Timers_extension.html#Timers">Timers</a></li><li><a href="Twitch_extension.html#Twitch">Twitch</a></li><li><a href="TwitchChat_extension.html#TwitchChat">TwitchChat</a></li><li><a href="Twitter_extension.html#Twitter">Twitter</a></li><li><a href="Users_extension.html#Users">Users</a></li><li><a href="YouTube_extension.html#YouTube">YouTube</a></li><li><a href="chatbot_extension.html#chatbot">chatbot</a></li></ul><h3>Global</h3><ul><li><a href="global.html#SaveConfigToServer">SaveConfigToServer</a></li><li><a href="global.html#SendSettingsWidgetLarge">SendSettingsWidgetLarge</a></li><li><a href="global.html#SendSettingsWidgetSmall">SendSettingsWidgetSmall</a></li><li><a href="global.html#SetupWebpageServer">SetupWebpageServer</a></li><li><a href="global.html#UpdateEncodersAvailable">UpdateEncodersAvailable</a></li><li><a href="global.html#buildFFMPEGArgs">buildFFMPEGArgs</a></li><li><a href="global.html#checkFFMPEGAvailabilities">checkFFMPEGAvailabilities</a></li><li><a href="global.html#checkFFMPEGInstall">checkFFMPEGInstall</a></li><li><a href="global.html#createCheckBox">createCheckBox</a></li><li><a href="global.html#downloadFFMPEG">downloadFFMPEG</a></li><li><a href="global.html#ffmpegBusyFlags">ffmpegBusyFlags</a></li><li><a href="global.html#findTriggerByMessageType">findTriggerByMessageType</a></li><li><a href="global.html#getDebug">getDebug</a></li><li><a href="global.html#getEncoderOptions">getEncoderOptions</a></li><li><a href="global.html#getEncoders">getEncoders</a></li><li><a href="global.html#getFFMPEGCommand">getFFMPEGCommand</a></li><li><a href="global.html#getInstalledFFMPEGs">getInstalledFFMPEGs</a></li><li><a href="global.html#handleExit">handleExit</a></li><li><a href="global.html#heartBeatCallback">heartBeatCallback</a></li><li><a href="global.html#init">init</a></li><li><a href="global.html#initialise">initialise</a></li><li><a href="global.html#killProcess">killProcess</a></li><li><a href="global.html#onDataCenterConnect">onDataCenterConnect</a></li><li><a href="global.html#onDataCenterDisconnect">onDataCenterDisconnect</a></li><li><a href="global.html#onDataCenterMessage">onDataCenterMessage</a></li><li><a href="global.html#parseEncodersString">parseEncodersString</a></li><li><a href="global.html#parseSettingsWidgetLarge">parseSettingsWidgetLarge</a></li><li><a href="global.html#parseSettingsWidgetSmall">parseSettingsWidgetSmall</a></li><li><a href="global.html#printProgress">printProgress</a></li><li><a href="global.html#runFFMPEG">runFFMPEG</a></li><li><a href="global.html#saveCredentialsToServer">saveCredentialsToServer</a></li><li><a href="global.html#sendAction">sendAction</a></li><li><a href="global.html#sendOBSStartAction">sendOBSStartAction</a></li><li><a href="global.html#sendOBSStopAction">sendOBSStopAction</a></li><li><a href="global.html#sendStreamStartedTrigger">sendStreamStartedTrigger</a></li><li><a href="global.html#sendStreamStoppedTrigger">sendStreamStoppedTrigger</a></li><li><a href="global.html#sendTrigger">sendTrigger</a></li><li><a href="global.html#setDebug">setDebug</a></li><li><a href="global.html#startStream">startStream</a></li><li><a href="global.html#stopStream">stopStream</a></li><li><a href="global.html#unzipfile">unzipfile</a></li><li><a href="global.html#updateEncoderWebJSONFile">updateEncoderWebJSONFile</a></li><li><a href="global.html#useStreamRollerFfmpeg">useStreamRollerFfmpeg</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Sat Apr 05 2025 03:42:18 GMT+0100 (British Summer Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
